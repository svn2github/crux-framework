= 1 Introduction =

= 2 Quick Start=

== 2.1 Install ==

== 2.2 Sample Application ==

== 2.3 Create an Application ==

= 3 Coding Client Side =

_*Crux*_ applications are basically GWT applications. It means that you must attempt to all GWT restrictions in terms of source code limitations an project structure directives.

If you are not familiar with GWT, please consult its [http://code.google.com/intl/pt-BR/webtoolkit/ documentation] first.

Your modules must inherits _*br.com.sysmap.crux.core.Crux.gwt.xml*_. You don't need to specify an EntryPoint, because _*Crux*_ defines a basic one that starts a parser on page document to replace the marker `<span>` tags to widgets. 

If you need to create a new EntryPoint, your class must override the _*Crux*_ EntryPoint ({{{br.com.sysmap.crux.core.client.JSEngine}}}) and call super on your onModuleLoad() method.

The following example shows a module that can use any widget provided by default distribution of Crux:
{{{
<module rename-to='cruxtest'>
	<inherits name='br.com.sysmap.crux.core.Crux'/>
	<inherits name='br.com.sysmap.crux.basic.CruxBasicWidgets'/>
	<inherits name='br.com.sysmap.crux.advanced.CruxAdvancedWidgets'/>
</module>
}}}

The code above creates a module that inherits the _*Crux*_ core and the two sets of widgets that compose the default distribution. The BasicWidgets set contains all widgets that is distributed directly with GWT. The Advanced set contains some complex widgets like MaskedTexBox, multi-frame capable dialogs, etc.

== 3.1 Building User Interface ==

Any GWT widget can be used in user interface construction. Default _*Crux*_ distribution supports the use of any widget included in the [http://code.google.com/intl/pt-BR/webtoolkit/doc/1.6/DevGuideUserInterface.html GWT default distribution]. To use any of those widgets, you must ensure that the file crux-basicwidgets.jar is present in the WEB-INF/lib folder of your application. Adavanced widgets are also availabe through crux-advancedwidgets.jar. Consult the [ComponentDeveloperManual Component Developer Manual] for information about how to use custom widgets with _*Crux*_.

To add widgets to your pages, you can use one of these three methods:
  # Declare a _`<span>`_ tag with an attribute `_`type to inform which widget you want to add to the page.
  # Use _*HtmlTags*_ tool to build a page as a XML file and use some XSDs to enable auto completion on your favorite editor.
  # Programmatically create a widget, exactly as you already do using with pure GWT. 

=== 3.1.1 Writing HTML Pages===
The following code is an example of the first method:
{{{
<html>
   <head>
       <script language='javascript' src='cruxtest/cruxtest.nocache.js'></script>
   </head>
   <body>
       <span id='myBox' _type='textBox' />
       <span id='myButton' _type='button' _text='Hello' _onclick='clientHandler.helloWorld' />
   </body>
</html>
}}} 

You can consult the following [Widgets#Basic_Widgets table] to verify the type for default GWT widgets.



=== 3.1.2 Writing XML Pages===
Now, you can see an example of the second method:
{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux/ui/1.0" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <crux:textBox id="myBox" />
       <crux:button id="myButton" text="Hello" onClick="clientHandler.helloWorld" />
   </body>
</html>
}}} 

If you decide to use this approach, you must attempt to:
  * Your files must have the extension *_.crux.xml_*.

  * In order to enable auto completion, you need to configure your IDE to point to the following XSD files:
    * [xhtml.xsd xhtml.xsd]
    * [crux-basicwidgets.xsd crux-basicwidgets.xsd]
    * [crux-advancedwidgets.xsd crux-advancedwidgets.xsd]

  * Configure the HtmlTagsFilter in your web.xml files as following:
{{{
<filter>
   <display-name>HtmlTagsFilter</display-name>
   <filter-name>HtmlTagsFilter</filter-name>
   <filter-class>br.com.sysmap.crux.tools.htmltags.filter.HtmlTagsFilter</filter-class>
   <init-param>
      <param-name>outputCharset</param-name>
      <param-value>ISO-8859-1</param-value>
   </init-param>
</filter>
<filter-mapping>
   <filter-name>HtmlTagsFilter</filter-name>
   <url-pattern>*.html</url-pattern>
</filter-mapping>
}}}

Note that if you use the [UserManual#CruxProjectGenerator Crux Project Generator], it will already configure the filter for you.

This filter will intercept the requests to transform your *_.crux.xml_* files in *_.html_* files that uses _`<span>`_ tags, exactly as the page showed in the first method. It just need to be done in a development scenario. Before you put your application in production, you compile your code (see [UserManual#Compilation compilation]) and the transformation is done only at this moment.

If the filter is used in a production scenario, it will just do nothing. 

=== 3.1.3 Creating Widgets Programatically===

You can create widgets exactly as you create using GWT directly. You can add an EventHandler to be called when the screen is loaded (see [UserManual#Managing_Events Managing Events] to more details about events). Inside your EventHandler, you can build Widgets as in the following example:
{{{
   ...
   Button myButton = new Button();
   myButton.addClickHandler(new ClickHandler(){
      public void onClick(ClickEvent event)
      {
          Window.alert("hello");
      }
   });
   ...
}}}

== 3.2 Screen ==

_*Crux*_ creates an abstraction over the page that is called *_Screen_*. Declaratively, you can refer to it using a `<span>` with `_`type="screen":

{{{
<html>
   <head>
       <script language='javascript' src='cruxtest/cruxtest.nocache.js'></script>
   </head>
   <body>
       <span _type='screen' _onclose='clientHandler.onClose' _usecontroller="clientHandler">
	       <span id='myBox' _type='textBox' />
	       <span id='myButton' _type='button' _text='Hello' _onclick='clientHandler.helloWorld' />
       </span>
   </body>
</html>
}}}

If you are using XML files with HTMLTags plugin, you can write:

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux/ui/1.0" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <crux:screen onClose='clientHandler.onClose' onLoad='clientHandler.onLoad' useController="clientHandler" />
       <crux:textBox id="myBox" />
       <crux:button id="myButton" text="Hello" onClick="clientHandler.helloWorld" />
   </body>
</html>
}}}

The screen can be retrieve programatically by a call to the static method {{{Screen.get()}}}.
Through Screen, you can:
  # Access any widget created decaratively on pages.
  # Add handlers to Window events, like load, close or resize.
  # Communicate with other screens to, for example, exchange data between _*Crux*_ pages in different frames or windows of the same application.
  # Control the history without need to add a hidden frame directly on the page.
  # Block and unblobck the user intercation with the page.

=== 3.2.1 Access Screen Widgets ===

To access screen widgets, you can use the static method {{{Screen.get(screenId)}}}.

{{{
	Button myButton = (Button)Screen.get("myButton");
	or
	Button myButton = Screen.get("myButton", Button.class);
}}}

You can also create an interface to access your widgets on screen. Your interface must extends the interface ScreenWrapper and the methods must follow the pattern: {{{<widgetType> get<WidgetID>()}}}. See the example:
{{{
@Controller("myController")
public class MyClass
{
	public static interface MyScreen extends ScreenWrapper
	{
		Button getMyButton();
		TextBox getMyBox();
	}
	
	protected MyScreen myScreen = GWT.create(MyScreen.class);

	public void myMethod()
	{
		myScreen.getMyBox().setValue("Test");
	}
}
}}}

We recomend that you create wrappers for screens, that is most elegant and avoid mismatches on typing widgets ids as strings all over the code.

=== 3.2.2 Screen Events ===

_*Crux*_ Screen support the following events:
|| *Event* || *Description* ||
||Load||Called when page loads. It is fired after the screen's building process is completed||
||Close||Called when page is colsed||
||Closing||Called before close the page||
||Resize||Called on page resize||
||HistoryChanged||Called when back button is pressed||

=== 3.2.3 Communication Between Screens===

Using some static methods on Screen class, it is possible to invoke operations on other _*Crux*_ screens running in different frames or windows.

The following example shows how this can be done:

{{{
	Screen.invokeControllerOnTop("topController.method", new MyParameterClass());
}}}

That code will call the method "method" on controller identified by "topController" on the top page. Consult the section [UserManual#Managing_Events Managing Events] for more details about how this call is processed.

The following table shows the methods that allows calls on others screens:

|| *Method* || *Description* ||
||invokeControllerOnParent||call a controller on parent page||
||invokeControllerOnOpener||call a controller on opener page||
||invokeControllerOnAbsoluteTop||call a controller on top of the first opener page||
||invokeControllerOnTop||call a controller on top page||
||invokeControllerOnSelf||call a controller on self||

You can create an interface to wrap the invocations to a specific controller. Your interface must extends the interface {{{Invoker}}} and the methods must follow the pattern: {{{<returnType> <methodName>On<position>(<paramType>);}}}. See the example:
{{{
public interface MyControllerInvoker extends Invoker
{
   void myMethodOnTop(String[] params); // is the same that Screen.invokeControllerOnTop("myController.myMethod", params);
   String mySecondMethodOnSelf();
   String mySecondMethodOnOpener(Integer param0, String param1, String[] param2);
}
}}}

{{{
   ...
   MyControllerInvoker invoker = GWT.create(MyControllerInvoker.class);
   invoker.myMethodOnTop(new String[]{"value1", "value2"});
   ...
}}}

To inform the name of the controller that will be bound to the invoker interface, you can use the annotation {{{@ControllerName}}}. If it is not present, _*Crux*_ will use the name of the invoker interface without the suffix 'Invoker'.

The above interface could also be written as:
{{{
@ControllerName("controller")
public interface MyControllerInvoker extends Invoker
{
   ...
}
}}}

Another way of information sharing is availabe for _*Crux*_ screens. You can use a common context to read and write variables.

The _*Crux*_ Context is a common area where you can put and read values associating them with a key.

To turn easier the access to context information, you can define an interface that extends the interface {{{Context}}}. Its methods must follow the pattern: {{{<valueType> get<valueKey>()}}} or {{{void set<valueKey>(valueType)}}}. See the example:

{{{
public interface MyContextWrapper extends Context
{
	Double getValueOne();
	String[] getValueTwo();
	void setValueTwo(String[] value);
}
}}}


{{{
@Controller("myController")
public class MyClass
{	
	public void myMethod()
	{
		MyContextWrapper context = GWT.create(MyContextWrapper.class);
		context.setValueTwo(new String[]{"Value One", "Value Two"});
		Window.alert(context.getValueTwo()[0]);
	}
}
}}}

If you pass null as argument for a setter method of a Context Wrapper object, it will remove that value from context. Example:

{{{
	context.setValueTwo(null);
}}}

Note that you can have more than one Context Wrapper. Different modules can use different wrappers if you want. However, the area where context information is written is unique.
It's important to advice that you must initialize the context before using it. This can be done this way:

{{{
Screen.createContext();
}}}

If you call {{{Screen.createContext()}}} more than once, you will erase the context and create a new one.

Screen class has the following static methods to support Context management:

|| *Method* || *Description* ||
||createContext||Initialize the context. It just need to be called once in one of the modules that are sharing information.||
||clearContext||remove all context entries||

Behind the scenes, Context is managed by a ContextHandler object. It is provided two implementations for this interface:
|| *Handler* || *Description* || 
||CookieContextHandler||Use cookies to store values||
||TopContextHandler||Store values in a HashMap located on top of the first opener window||

The default implementation is CookieContextHandler. However, each one has pros and cons.

*TopContextHandler* is faster and does not leave data after the application is closed. It is not possible to have dirty read, because the context area is created only when used for the first time. However, in a multi window application, the context data is lost if top window is closed.

*CookieContextHandler* never loses data if a window is closed. However, you must ensure that you call the method {{{Screen.createContext()}}} in your application to avoid dirty reads (cookies can contain old values from a previous execution).

If you desire, you can add the following lines to your module config file to change the default context behaviour:
{{{
	<replace-with class="br.com.sysmap.crux.core.client.context.TopContextHandler">
		<when-type-assignable class="br.com.sysmap.crux.core.client.context.ContextHandler" />
	</replace-with>			
}}}


=== 3.2.4 Control History ===

Screen provides a simple mechanism to manage history. Using the static method {{{Screen.addToHistory(String token)}}} you can create a history token (exactly as [http://code.google.com/docreader/#p=google-web-toolkit-doc-1-5&s=google-web-toolkit-doc-1-5&t=DevGuideHistory GWT tokens]). To handle the changes on history, you can add a handler to HistoryChanged events, as you can see in the next example:

{{{
	// To put a token on history
	Screen.addToHistory("link1Clicked");
}}}

{{{
	// To add a HistoryChanged Handler
	Screen.addHistoryChangedHandler(new addValueChangeHandler<String>(){
		public void onValueChange(ValueChangeEvent<String> event)
		{
			Window.alert(event.getValue());
		}
	});
}}}

or Declaratively:

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux/ui/1.0" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <crux:screen useController="clientHandler" onClose='clientHandler.onClose' onLoad='clientHandler.onLoad' onHistoryChanged='clientHandler.onHistoryChanged' />
   </body>
</html>
}}}

Note that you don't need here to add any iFrame to your host page, as in pure GWT.

=== 3.2.5 Block and Unblock ===

You can block and unblock the user interaction with the page using the static methods {{{Screen.blockToUser()}}} e {{{Screen.unblockToUser()}}}. See the following example:

{{{
  ...
   protected TestServiceAsync service = (TestServiceAsync) GWT.create(TestService.class);

   public void helloWorld()
   {
        Screen.blockToUser();
        service.hello(new AsyncCallback<String>()
        {
                public void onSuccess(String s) 
                {
                        Screen.unblockToUser();
                        Window.alert(s);
                }
                public void onFailure(Throwable e) 
                {
                        Screen.unblockToUser();
                        Window.alert(e.getMessage());
                }
        });
   }   
   ...
}}} 

== 3.3 Managing Events ==

It's possible to add event handlers:
  # Declaratively.
  # Programatically.

=== 3.3.1 Add Event Declaratively===
To add an event declaratively, you must create a [UserManual#Controller Controller] and give it a name.

If you are creating your pages without the [HtmlTags plugin] support, you can declare attributes in the {{{<span>}}} element that define the widget properties following the pattern {{{_on<eventName> = "<controllerName>.<methodName>"}}}.

{{{
<html>
   <head>
       <script language='javascript' src='cruxtest/cruxtest.nocache.js'></script>
   </head>
   <body>
       <span _type='screen' _onclose='clientHandler.onClose' _usecontroller='clientHandler'>
	       <span id='myBox' _type='textBox' _onchange='clientHandler.helloWorld'/>
	       <span id='myButton' _type='button' _onclick='clientHandler.helloWorld' />
       </span>
   </body>
</html>
}}}

Note that you must also "import" your controller through the attribute {{{_usecontroller}}} of the screen's tag.

If you decide to use the HtmlTags Plugin, you can write:

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux/ui/1.0" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <crux:screen onClose='clientHandler.onClose' useController="clientHandler" >
	       <crux:textBox id="myBox" />
	       <crux:button id="myButton" text="Hello" onClick="clientHandler.helloWorld" />
	   </crux:screen>
   </body>
</html>
}}}

=== 3.3.2 Add Event Programatically===

You can still use the default GWT mechanism to add handlers for events programatically, like:

{{{
   ...
   Button myButton = new Button();
   myButton.addClickHandler(new ClickHandler(){
      public void onClick(ClickEvent event)
      {
          Window.alert("hello");
      }
   });
   ...
}}}

The only point to observe here is that you need to put this code in some controller method that is called declaratively, unless you has overwriten the _*Crux*_ EntryPoint and call it directly from there.

=== 3.3.3 Controller===
Controller classes are called to handle events. 

To Create a Controller, you just create a simple java class with the {{{@Controller}}} annotation. That annotation has a value property to inform the name of the controller. That is the name used on pages to point to the controller.

See the following example:

{{{
@Controller("clientHandler")
public class MyController
{
   ... // event handlers here
}
}}}

Your controller can have a lot of methods to handle events. These methods must follow the conditions:
  # It must have public visibility;
  # It must have zero or one argument. If an argument is present, it must be an GwtEvent an this method only will be able to handle this type of events.
  # It must be marked with the annotation {{{@Expose}}}.

See the example:
{{{
@Controller("clientHandler")
public class MyController
{
   @Expose
   public void onClose(CloseEvent<Window> event)
   {
       // code here   
   }
   
   @Expose
   public void helloWorld()
   {
       // code here   
   }
   
   @Expose
   public void onClick(ClickEvent event)
   {
       // code here   
   }
   
   protected void myMethod(String string)
   {
       // code here   
   }
}
}}}

==== 3.3.3.1 The @Controller Annotation====

The Controller annotation has the following properties:

|| *Property* || *Required* || *Default Value* || *Description* ||
||value||yes|| none ||defines the name of the controller. Used inside pages to point to the controller||
||statefull||no||true||If true, one controller object is created and the same instance is <br>used to handle all events. If false, a new instance is used for each new event||
||autoBind||no||true||If true, [UserManual#Value_Binding ValueObjects] are automatically bound from screen widgets before the event <br>occurs and bound back to screen widgets when the event handling terminates ||

==== 3.3.3.2 The @Create Annotation====

This annotation can be used to simplify the code for Controllers. It only can be used inside a controller class and it automatically creates an object (according with field type) and initialize the field with this value.

This creation is done by a call to GWT.create method, assuring that any generator eventually associated with the requested type will be called correctly.

The code showed in sections [UserManual#Access_Screen_Widgets Access Screen Widgets], [UserManual#Communication_Between_Screens Communication Between Screens], [UserManual#Communication_Between_Screens Communication Between Screens] and [UserManual#Block_and_Unblock Block and Unblock] could be written as:

{{{
@Controller("myNewController")
public class MyClass
{
    public static interface MyScreen extends ScreenWrapper
    {
        Button getMyButton();
        TextBox getMyBox();
    }
	
    @Create
    protected MyScreen myScreen;

    @Create
    protected MyContextWrapper context;

    @Create
    protected TestServiceAsync service;

    @Create
    protected MyControllerInvoker invoker;

    @Expose
    public void myMethod()
    {
        myScreen.getMyBox().setValue("Test");
        context.setValueTwo(new String[]{"Value One", "Value Two"});
    }
}
}}}

Note that {{{@Create}}} can handle service creation too, despite the fact that the variable type is not the same passed to {{{GWT.create}}} (in above example would be {{{TestService}}}).

You must note, however, that to a field can be created through {{{@Create}}} annotation, that field must has public or protected visibility or has a public getter and setter methods.

====3.3.3.3 Value Binding====

_*Crux*_ provides a mechanism to help you to automatically bind values between screen widgets and data objects.

You can create an value object and annotate it with {{{@ValueObject}}} annotation. Doing it, you allows _*Crux*_ to populate an object of this type with values present on screen widgets before run the event handler methods. After method execution, the screen is also updated with any change in these objects.

See the following example:

{{{
@ValueObject
public class Person implements Serializable
{
	private static final long serialVersionUID = -783134338059796761L;

	private String name;
	private String phone;
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getPhone() {
		return phone;
	}
	public void setPhone(String phone) {
		this.phone = phone;
	}
}
}}}

{{{
@Controller("myController")
public class MyClass
{
    @Create
    protected Person person;

    @Expose
    public void myMethod()
    {
    	Window.alert(person.getName());
    	person.setPhone("1234-5678");
    }
}
}}}

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux/ui/1.0" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <crux:screen useController="myController" >
	       <crux:textBox id="name" />
	       <crux:textBox id="phone" />
	       <crux:button id="myButton" text="Hello" onClick="myController.myMethod" />
	   </crux:screen>
   </body>
</html>
}}}

In the above example, the value of the "name" textBox on page will be bound to field "name" of the Person object created by controller (the same is true to "phone"). After the handler execution, the changes made in the value object will be reflected on page. 

If want, you can use the {{{@ScreenBind}}} annotation on value object field to inform _*Crux*_ which widget will be bound to this field. The above example can be changed to:

{{{
@ValueObject
public class Person implements Serializable
{
	private static final long serialVersionUID = -783134338059796761L;

	@ScreenBind("person.name")
	private String name;

	@ScreenBind("person.phone")
	private String phone;
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getPhone() {
		return phone;
	}
	public void setPhone(String phone) {
		this.phone = phone;
	}
}
}}}

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux/ui/1.0" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <crux:screen useController="myController" >
	       <crux:textBox id="person.name" />
	       <crux:textBox id="person.phone" />
	       <crux:button id="myButton" text="Hello" onClick="myController.myMethod" />
	   </crux:screen>
   </body>
</html>
}}}

You can also controll which fields of a value object must be bound to some widget screen. {{{@ValueObject}}} annotation has a boolean propertie called {{{bindWidgetByFieldName}}} (default to true). Setting this value to false make _*Crux*_ to does not bind all value object fields to widgets automatically. If you set this, you must specify for each field, the name of the widget that it will be bound (through {{{@ScreenBind}}} annotation).

See the following example:
{{{
@ValueObject(bindWidgetByFieldName=false)
public class Person implements Serializable
{
	private static final long serialVersionUID = -783134338059796761L;

	@ScreenBind("person.name")
	private String name;

	@ScreenBind
	private String phone; //will be bound to "phone" widget
	
	private String address; // will not be bound.
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getPhone() {
		return phone;
	}
	public void setPhone(String phone) {
		this.phone = phone;
	}
	public String getAddress() {
		return address;
	}
	public void setAddress(String address) {
		this.address = address;
	}
}
}}}

Any field in a value object can be bound to a widget if it:
  * is a primitive type (or a primitive wrapper);
  * is a CharSequence type (String, StringBuilder, StringBuffer, etc);
  * is a Date type (java.util.Date, java.sql.Date, java.sql.Timestamp, etc);
  * is an Enum type;
  * is any type annotated with {{{@ValueObject}}} annotation;
  * has public or protected visibility or has public getter and setter methods.

The following code shows more examples:

{{{
@ValueObject
public class Person implements Serializable
{
	private static final long serialVersionUID = -783134338059796761L;

	private String name;
	private Date birth;
	private Address address; 
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public Date getBirth() {
		return birth;
	}
	public void setBirth(String birth) {
		this.birth = birth;
	}
	public Address getAddress() {
		return address;
	}
	public void setAddress(Address address) {
		this.address = address;
	}
}
}}}

{{{
@ValueObject
public class Address implements Serializable
{
	private static final long serialVersionUID = -231134901059796145L;

	private String street;
	
	public String getStreet() {
		return street;
	}
	public void setStreet(String street) {
		this.street = street;
	}
}
}}}

If you want to disable the automatic value binding mechanism to a specific controller, you can set the {{{@Controller}}} property {{{autoBind}}} to false. You can, later, control the value object and screen updates through methods {{{Screen.updateScreen(controller)}}} and
{{{Screen.updateController(controller)}}}. See the following example:

{{{
@Controller(value="myController", autoBind=false)
public class MyClass
{
    @Create
    protected Person person;

    @Expose
    public void myMethod()
    {
    	Screen.updateController(this);
    	Window.alert(person.getName());
    	person.setPhone("1234-5678");
    	Screen.updateScreen(this);
    }
}
}}}

==== 3.3.3.4 Using Controllers on Screen====

To inform that a controller will be used on a screen, you must explicity "import" it using the {{{_usecontroller}}} (or {{{{useController}}}, with HtmlTags Plugin).

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux/ui/1.0" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <crux:screen useController="myController, myOtherController" >
	   </crux:screen>
   </body>
</html>
}}}

It is necessary for performance reasons.

However, if you want that a controller be imported in every screen you have, you can put an annotation {{{@Global}}} in the Controller class.

{{{
@Global
@Controller("myController")
public class MyClass
{
       // code here
}
}}}

That will allow this controller methods to be called even if no {{{useController}}} declaration is present on your screen.

==== 3.3.3.5 Comunication Between Controllers====

In section [UserManual#Communication_Between_Screens Communication Between Screens] we show how you can, from a controller, to invoke methods on another controller. Now we will see the details associated with the methods of those controllers.

The first point is that you must explicity inform _*Crux*_ that an event handler can be called from out of the current page (by another document). To do this, you must put an annotation {{{@ExposeOutOfModule}}} on the method you want to expose.

{{{
@Controller("myController")
public class MyClass
{
    @ExposeOutOfModule
    public void myMethod()
    {
       // code here
    }
}
}}}

Now, other pages can call this method through {{{Screen.invokeControllerOn<?>()}}} methods.

For calls to {{{Screen.invokeControllerOnSelf()}}} the handler does not need to be exposed to out of module. You can call a handler exposed only with {{{@Expose}}} annotation.

So we can talk about two kinds of controller methods invocation. One remote and one local. Remote calls are those made to another pages (top, parent, opener, etc) and local are made to the same page (self).

An event handler for calls made through screen invoker methods, can receive an {{{InvokeControllerEvent}}} parameter. This class provides a method to access values passed as argument in method invocation.

See the example:

{{{
   ...
   Window.alert(Screen.invokeControllerOnTop("myController.hello","Thiago"));
   Window.alert(Screen.invokeControllerOnSelf("myController.helloLocal","Thiago"));
   Window.alert(Screen.invokeControllerOnSelf("myController.parametersExample",new Object[]{new Integer(123), "Thiago", new Boolean(true)}));
   ...
}}}

or 

{{{
   ...
   Window.alert(myControllerInvoker.helloOnTop("Thiago"));
   Window.alert(myControllerInvoker.helloLocalOnSelf("Thiago"));
   Window.alert(myControllerInvoker.parametersExample(1234, "Thiago", true));
   ...
}}}

{{{
@Controller("myController")
public class MyClass
{
    @ExposeOutOfModule
    public String hello(InvokeControllerEvent event)
    {
       String param = event.getParameter(String.class);
       return "Hello "+param;
    }

    @Expose
    public String helloLocal(InvokeControllerEvent event)
    {
       String param = event.getParameter(String.class);
       return "Hello "+param;
    }

    @ExposeOutOfModule
    public String parametersExample(InvokeControllerEvent event)
    {
       if (event.getParameterCount() == 3)
       {
          int param0 = event.getParameter(0, Integer.class);
          String param1 = event.getParameter(1, String.class);
          boolean param2 = event.getParameter(2, Boolean.class);
          return "Hello "+param0;
       }
       return null;
    }
}
}}}

===== 3.3.3.5.1 Parameter types=====

The following types are allowed as arguments to a remote call to a controller method:
  * Primitive types (or a primitive wrapper);
  * CharSequence types (String, StringBuilder, StringBuffer, etc);
  * Date types(java.util.Date, java.sql.Date, java.sql.Timestamp, etc);
  * Enum types;
  * Any type that implements the interface {{{CruxSerializable}}}.
  * Arrays of any of those types above;
  
So, if you need to pass a custom object to another page, your object class must implements the interface CruxSerializable. This interface forces your type to implement a serialize and deserialize methods.

For local calls, any type is allowed, once no serialization is needed.
  
If you define a custom serializable type, you must inform _*Crux*_ explicity that you  want to use such type in your module. You can do it declaratively using {{{_useserializer}}} attibute on screen tag, or through the method {{{ModuleComunicationSerializer.registerCruxSerializable}}}.

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux/ui/1.0" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <crux:screen useController="myController" useSerializable="mySerializableType">
	   </crux:screen>
   </body>
</html>
}}}

{{{
@SerializableName("mySerializableType")  
public class MySerializableType implements CruxSerializable
{
   ...
}
}}}

or 

{{{
   ModuleComunicationSerializer.registerCruxSerializable(MySerializableType.class.getName(), new MySerializableType());
}}}

The annotation {{{@SerializableName}}} could be used to simplify the name you write on screen tag.

== 3.4 I18N ==

== 3.5 Client-Server Communication ==

= 4 Coding Server Side =

== 4.1 I18N ==

= 5 Extending and Customizing =