= 1 Introduction =

_*Crux*_ applications are basically GWT applications. It means you must attempt to all GWT restrictions in terms of source code limitations and project structure directives.
If you are not familiar with GWT, please consult its [http://code.google.com/intl/pt-BR/webtoolkit/ documentation] first.

This documentation will show you, in a detailed and gradual way, how to use the _*Crux*_ framework, by exploring and exemplifying its features. Here you will also learn the concepts behind the code and understand how does _*Crux*_ work internally. In order to easy follow this documentation you will need:
  * A [http://java.sun.com/javase/downloads/index.jsp Java SE Development Kit (JDK)], version 1.5 or higher (we recommend using 1.6);
  * An [http://www.eclipse.org/downloads/packages/ Eclipse] IDE;

= 2 Quick Start=

== 2.1 Install ==

  * Download the lastest _*Crux*_ release [Release here];
  * Unzip the archive into a folder you want;
  * Edit the file named {{{project.properties}}}, setting your project attributes;
  * Open a command line shell and run the script {{{projectGenerator}}}, as shown below:
  {{{
  	projectGenerator "path/to/eclipse/workspace"
  }}}
  This command will create an Eclipse project, with the name you informed in the properties file.
  
  * Import the generated project into your Eclipse IDE, and you will get something like this:
  
  http://crux-framework.googlecode.com/svn/wiki/images/generated-project.gif
   
  * Run the {{{<your project name>.launch}}} file, located at the project root folder;
  * If everything's gone ok, the GWT Hosted Mode console will appear, and you first application will look like this:
  
  http://crux-framework.googlecode.com/svn/wiki/images/generated-project-running.gif
  	  


== 2.2 Sample Application ==

Here we will explore the application generated on the previous section, explaining each single part of it.

  * *The  {{{war}}} folder* is the root context of your application, containing: 
    * a folder called {{{style}}}, where reside the look-and-feel resources (images and CSS files);
    * a WEB-INF folder, compliant with JEE specifications, containing:
      * the {{{web.xml}}} file (more details at [UserManual#4.3.1_Web.xml 4.3.1 Web.xml]);
      * the {{{lib}}} folder, which stores all _*Crux*_ jar files your need at development time (more details about _*Crux*_ jars at [CruxLibs Crux Libs]);
      * a {{{classes}}} folder, which is the output for java compilation;
      * a {{{<the name you gave>.crux.xml}}} file: the _welcome file_ of your application;
    * the {{{src}}} folder, containing the source files:
      * {{{<the name you gave to the module>.gwt.xml}}} - a GWT module which extends _*Crux*_ modules;
      * {{{<the same module package>.client.controller.MyController.java}}} - a client-side controller for the welcome page;
      * {{{<the same module package>.client.remote.GreetingService.java}}} -  a client-side business interface;
      * {{{<the same module package>.client.remote.GreetingServiceAsync.java}}} -  a client-side asynchronous interface for accessing the server;
      * {{{<the same module package>.server.GreetingServiceImpl.java}}} -  the server-side business class;
      
      
      

== 2.3 Create an Application ==

= 3 Coding Client Side =


Your modules must inherit _*br.com.sysmap.crux.core.Crux.gwt.xml*_. You don't need to specify an EntryPoint, because _*Crux*_ defines a basic one that starts a parser on page document to replace the marker `<span>` tags to widgets. 

If you need to create a new EntryPoint, your class must override the _*Crux*_ EntryPoint ({{{br.com.sysmap.crux.core.client.JSEngine}}}) and call super on your onModuleLoad() method.

The following example shows a module that can use any widget provided by default distribution of Crux:
{{{
<module rename-to='cruxtest'>
	<inherits name='br.com.sysmap.crux.core.Crux'/>
	<inherits name='br.com.sysmap.crux.basic.CruxBasicWidgets'/>
	<inherits name='br.com.sysmap.crux.advanced.CruxAdvancedWidgets'/>
</module>
}}}

The code above creates a module that inherits the _*Crux*_ core and the two sets of widgets that compose the default distribution. The BasicWidgets set contains all widgets that are distributed directly with GWT. The Advanced set contains some complex widgets like MaskedTexBox, multi-frame capable dialogs, etc.

== 3.1 Building User Interface ==

Any GWT widget can be used in user interface construction. Default _*Crux*_ distribution supports the use of any widget included in the [http://code.google.com/intl/pt-BR/webtoolkit/doc/1.6/DevGuideUserInterface.html GWT default distribution]. To use any of those widgets, you must ensure that the file crux-basicwidgets.jar is present in the WEB-INF/lib folder of your application. Adavanced widgets are also availabe through crux-advancedwidgets.jar. Consult the [WidgetDeveloperManual Component Developer Manual] for information about how to use custom widgets with _*Crux*_.

To add widgets to your pages, you can use one of these three methods:
  # Declare a _`<span>`_ tag with an attribute `_`type to inform which widget you want to add to the page.
  # Use _*HtmlTags*_ tool to build a page as a XML file and use some XSDs to enable auto completion on your favorite editor.
  # Programmatically create a widget, exactly as you already do using with pure GWT. 

=== 3.1.1 Writing HTML Pages===
The following code is an example of the first method:
{{{
<html>
   <head>
       <script language='javascript' src='cruxtest/cruxtest.nocache.js'></script>
   </head>
   <body>
       <span id='myBox' _type='textBox' />
       <span id='myButton' _type='button' _text='Hello' _onclick='clientHandler.helloWorld' />
   </body>
</html>
}}} 

You can consult the following [Widgets#Basic_Widgets table] to verify the type for default GWT widgets.



=== 3.1.2 Writing XML Pages===
Now, you can see an example of the second method:
{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux/ui/1.0" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <crux:textBox id="myBox" />
       <crux:button id="myButton" text="Hello" onClick="clientHandler.helloWorld" />
   </body>
</html>
}}} 

If you decide to use this approach, you must attempt to:
  * Your files must have the extension *_.crux.xml_*.

  * In order to enable auto completion, you need to configure your IDE to point to the following XSD files:
    * [xhtml.xsd xhtml.xsd]
    * [crux-basicwidgets.xsd crux-basicwidgets.xsd]
    * [crux-advancedwidgets.xsd crux-advancedwidgets.xsd]

  * Configure the HtmlTagsFilter in your web.xml files as following:
{{{
<filter>
   <display-name>HtmlTagsFilter</display-name>
   <filter-name>HtmlTagsFilter</filter-name>
   <filter-class>br.com.sysmap.crux.tools.htmltags.filter.HtmlTagsFilter</filter-class>
   <init-param>
      <param-name>outputCharset</param-name>
      <param-value>ISO-8859-1</param-value>
   </init-param>
</filter>
<filter-mapping>
   <filter-name>HtmlTagsFilter</filter-name>
   <url-pattern>*.html</url-pattern>
</filter-mapping>
}}}

Note that if you use the [UserManual#CruxProjectGenerator Crux Project Generator], it will already configure the filter for you.

This filter will intercept the requests to transform your *_.crux.xml_* files in *_.html_* files that uses _`<span>`_ tags, exactly as the page showed in the first method. It just need to be done in a development scenario. Before you put your application in production, you compile your code (see [UserManual#Compilation compilation]) and the transformation is done only at this moment.

If the filter is used in a production scenario, it will just do nothing. 

=== 3.1.3 Creating Widgets Programatically===

You can create widgets exactly as you create using GWT directly. You can add an EventHandler to be called when the screen is loaded (see [UserManual#Managing_Events Managing Events] to more details about events). Inside your EventHandler, you can build Widgets as in the following example:
{{{
   ...
   Button myButton = new Button();
   myButton.addClickHandler(new ClickHandler(){
      public void onClick(ClickEvent event)
      {
          Window.alert("hello");
      }
   });
   ...
}}}

== 3.2 Screen ==

_*Crux*_ creates an abstraction over the page that is called *_Screen_*. Declaratively, you can refer to it using a `<span>` with `_`type="screen":

{{{
<html>
   <head>
       <script language='javascript' src='cruxtest/cruxtest.nocache.js'></script>
   </head>
   <body>
       <span _type='screen' _onclose='clientHandler.onClose' _usecontroller="clientHandler">
	       <span id='myBox' _type='textBox' />
	       <span id='myButton' _type='button' _text='Hello' _onclick='clientHandler.helloWorld' />
       </span>
   </body>
</html>
}}}

If you are using XML files with HTMLTags plugin, you can write:

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux/ui/1.0" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <crux:screen onClose='clientHandler.onClose' onLoad='clientHandler.onLoad' useController="clientHandler" />
       <crux:textBox id="myBox" />
       <crux:button id="myButton" text="Hello" onClick="clientHandler.helloWorld" />
   </body>
</html>
}}}

The screen can be retrieve programatically by a call to the static method {{{Screen.get()}}}.
Through Screen, you can:
  # Access any widget created decaratively on pages.
  # Add handlers to Window events, like load, close or resize.
  # Communicate with other screens to, for example, exchange data between _*Crux*_ pages in different frames or windows of the same application.
  # Control the history without need to add a hidden frame directly on the page.
  # Block and unblobck the user intercation with the page.

=== 3.2.1 Access Screen Widgets ===

To access screen widgets, you can use the static method {{{Screen.get(screenId)}}}.

{{{
	Button myButton = (Button)Screen.get("myButton");
	or
	Button myButton = Screen.get("myButton", Button.class);
}}}

You can also create an interface to access your widgets on screen. Your interface must extends the interface ScreenWrapper and the methods must follow the pattern: {{{<widgetType> get<WidgetID>()}}}. See the example:
{{{
@Controller("myController")
public class MyClass
{
	public static interface MyScreen extends ScreenWrapper
	{
		Button getMyButton();
		TextBox getMyBox();
	}
	
	protected MyScreen myScreen = GWT.create(MyScreen.class);

	public void myMethod()
	{
		myScreen.getMyBox().setValue("Test");
	}
}
}}}

We recomend that you create wrappers for screens, that is most elegant and avoid mismatches on typing widgets ids as strings all over the code.

=== 3.2.2 Screen Events ===

_*Crux*_ Screen support the following events:
|| *Event* || *Description* ||
||Load||Called when page loads. It is fired after the screen's building process is completed||
||Close||Called when page is closed||
||Closing||Called before close the page||
||Resize||Called on page resize||
||HistoryChanged||Called when back button is pressed||

=== 3.2.3 Communication Between Screens===

Using some static methods on Screen class, it is possible to invoke operations on other _*Crux*_ screens running in different frames or windows.

The following example shows how this can be done:

{{{
	Screen.invokeControllerOnTop("topController.method", new MyParameterClass());
}}}

That code will call the method "method" on controller identified by "topController" on the top page. Consult the section [UserManual#Managing_Events Managing Events] for more details about how this call is processed.

The following table shows the methods that allows calls on others screens:

|| *Method* || *Description* ||
||invokeControllerOnParent||call a controller on parent page||
||invokeControllerOnOpener||call a controller on opener page||
||invokeControllerOnAbsoluteTop||call a controller on top of the first opener page||
||invokeControllerOnTop||call a controller on top page||
||invokeControllerOnSelf||call a controller on self||

You can create an interface to wrap the invocations to a specific controller. Your interface must extends the interface {{{Invoker}}} and the methods must follow the pattern: {{{<returnType> <methodName>On<position>(<paramType>);}}}. See the example:
{{{
public interface MyControllerInvoker extends Invoker
{
   void myMethodOnTop(String[] params); // is the same that Screen.invokeControllerOnTop("myController.myMethod", params);
   String mySecondMethodOnSelf();
   String mySecondMethodOnOpener(Integer param0, String param1, String[] param2);
}
}}}

{{{
   ...
   MyControllerInvoker invoker = GWT.create(MyControllerInvoker.class);
   invoker.myMethodOnTop(new String[]{"value1", "value2"});
   ...
}}}

To inform the name of the controller that will be bound to the invoker interface, you can use the annotation {{{@ControllerName}}}. If it is not present, _*Crux*_ will use the name of the invoker interface without the suffix 'Invoker'.

The above interface could also be written as:
{{{
@ControllerName("controller")
public interface MyControllerInvoker extends Invoker
{
   ...
}
}}}

Another way of information sharing is availabe for _*Crux*_ screens. You can use a common context to read and write variables.

The _*Crux*_ Context is a common area where you can put and read values associating them with a key.

To turn easier the access to context information, you can define an interface that extends the interface {{{Context}}}. Its methods must follow the pattern: {{{<valueType> get<valueKey>()}}} or {{{void set<valueKey>(valueType)}}}. See the example:

{{{
public interface MyContextWrapper extends Context
{
	Double getValueOne();
	String[] getValueTwo();
	void setValueTwo(String[] value);
}
}}}


{{{
@Controller("myController")
public class MyClass
{	
	public void myMethod()
	{
		MyContextWrapper context = GWT.create(MyContextWrapper.class);
		context.setValueTwo(new String[]{"Value One", "Value Two"});
		Window.alert(context.getValueTwo()[0]);
	}
}
}}}

If you pass null as argument for a setter method of a Context Wrapper object, it will remove that value from context. Example:

{{{
	context.setValueTwo(null);
}}}

Note that you can have more than one Context Wrapper. Different modules can use different wrappers if you want. However, the area where context information is written is unique.
It's important to advice that you must initialize the context before using it. This can be done this way:

{{{
Screen.createContext();
}}}

If you call {{{Screen.createContext()}}} more than once, you will erase the context and create a new one.

Screen class has the following static methods to support Context management:

|| *Method* || *Description* ||
||createContext||Initialize the context. It just need to be called once in one of the modules that are sharing information.||
||clearContext||remove all context entries||

Behind the scenes, Context is managed by a ContextHandler object. It is provided two implementations for this interface:
|| *Handler* || *Description* || 
||CookieContextHandler||Use cookies to store values||
||TopContextHandler||Store values in a HashMap located on top of the first opener window||

The default implementation is CookieContextHandler. However, each one has pros and cons.

*TopContextHandler* is faster and does not leave data after the application is closed. It is not possible to have dirty read, because the context area is created only when used for the first time. However, in a multi window application, the context data is lost if top window is closed.

*CookieContextHandler* never loses data if a window is closed. However, you must ensure that you call the method {{{Screen.createContext()}}} in your application to avoid dirty reads (cookies can contain old values from a previous execution).

If you desire, you can add the following lines to your module config file to change the default context behaviour:
{{{
	<replace-with class="br.com.sysmap.crux.core.client.context.TopContextHandler">
		<when-type-assignable class="br.com.sysmap.crux.core.client.context.ContextHandler" />
	</replace-with>			
}}}


=== 3.2.4 Control History ===

Screen provides a simple mechanism to manage history. Using the static method {{{Screen.addToHistory(String token)}}} you can create a history token (exactly as [http://code.google.com/docreader/#p=google-web-toolkit-doc-1-5&s=google-web-toolkit-doc-1-5&t=DevGuideHistory GWT tokens]). To handle the changes on history, you can add a handler to HistoryChanged events, as you can see in the next example:

{{{
	// To put a token on history
	Screen.addToHistory("link1Clicked");
}}}

{{{
	// To add a HistoryChanged Handler
	Screen.addHistoryChangedHandler(new addValueChangeHandler<String>(){
		public void onValueChange(ValueChangeEvent<String> event)
		{
			Window.alert(event.getValue());
		}
	});
}}}

or Declaratively:

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux/ui/1.0" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <crux:screen useController="clientHandler" onClose='clientHandler.onClose' onLoad='clientHandler.onLoad' onHistoryChanged='clientHandler.onHistoryChanged' />
   </body>
</html>
}}}

Note that you don't need here to add any iFrame to your host page, as in pure GWT.

=== 3.2.5 Block and Unblock ===

You can block and unblock the user interaction with the page using the static methods {{{Screen.blockToUser()}}} e {{{Screen.unblockToUser()}}}. See the following example:

{{{
  ...
   protected TestServiceAsync service = (TestServiceAsync) GWT.create(TestService.class);

   public void helloWorld()
   {
        Screen.blockToUser();
        service.hello(new AsyncCallback<String>()
        {
                public void onSuccess(String s) 
                {
                        Screen.unblockToUser();
                        Window.alert(s);
                }
                public void onFailure(Throwable e) 
                {
                        Screen.unblockToUser();
                        Window.alert(e.getMessage());
                }
        });
   }   
   ...
}}} 

== 3.3 Managing Events ==

It's possible to add event handlers:
  # Declaratively.
  # Programatically.

=== 3.3.1 Add Event Declaratively===
To add an event declaratively, you must create a [UserManual#Controller Controller] and give it a name.

If you are creating your pages without the [HtmlTags plugin] support, you can declare attributes in the {{{<span>}}} element that define the widget properties following the pattern {{{_on<eventName> = "<controllerName>.<methodName>"}}}.

{{{
<html>
   <head>
       <script language='javascript' src='cruxtest/cruxtest.nocache.js'></script>
   </head>
   <body>
       <span _type='screen' _onclose='clientHandler.onClose' _usecontroller='clientHandler'>
	       <span id='myBox' _type='textBox' _onchange='clientHandler.helloWorld'/>
	       <span id='myButton' _type='button' _onclick='clientHandler.helloWorld' />
       </span>
   </body>
</html>
}}}

Note that you must also "import" your controller through the attribute {{{_usecontroller}}} of the screen's tag.

If you decide to use the HtmlTags Plugin, you can write:

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux/ui/1.0" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <crux:screen onClose='clientHandler.onClose' useController="clientHandler" >
	       <crux:textBox id="myBox" />
	       <crux:button id="myButton" text="Hello" onClick="clientHandler.helloWorld" />
	   </crux:screen>
   </body>
</html>
}}}

=== 3.3.2 Add Event Programatically===

You can still use the default GWT mechanism to add handlers for events programatically, like:

{{{
   ...
   Button myButton = new Button();
   myButton.addClickHandler(new ClickHandler(){
      public void onClick(ClickEvent event)
      {
          Window.alert("hello");
      }
   });
   ...
}}}

The only point to observe here is that you need to put this code in some controller method that is called declaratively, unless you has overwriten the _*Crux*_ EntryPoint and call it directly from there.

=== 3.3.3 Controller===
Controller classes are called to handle events. 

To Create a Controller, you just create a simple java class with the {{{@Controller}}} annotation. That annotation has a value property to inform the name of the controller. That is the name used on pages to point to the controller.

See the following example:

{{{
@Controller("clientHandler")
public class MyController
{
   ... // event handlers here
}
}}}

Your controller can have a lot of methods to handle events. These methods must follow the conditions:
  # It must have public visibility;
  # It must have zero or one argument. If an argument is present, it must be an GwtEvent an this method only will be able to handle this type of events.
  # It must be marked with the annotation {{{@Expose}}}.

See the example:
{{{
@Controller("clientHandler")
public class MyController
{
   @Expose
   public void onClose(CloseEvent<Window> event)
   {
       // code here   
   }
   
   @Expose
   public void helloWorld()
   {
       // code here   
   }
   
   @Expose
   public void onClick(ClickEvent event)
   {
       // code here   
   }
   
   protected void myMethod(String string)
   {
       // code here   
   }
}
}}}

==== 3.3.3.1 The @Controller Annotation====

The Controller annotation has the following properties:

|| *Property* || *Required* || *Default Value* || *Description* ||
||value||yes|| none ||defines the name of the controller. Used inside pages to point to the controller||
||statefull||no||true||If true, one controller object is created and the same instance is <br>used to handle all events. If false, a new instance is used for each new event||
||autoBind||no||true||If true, [UserManual#Value_Binding ValueObjects] are automatically bound from screen widgets before the event <br>occurs and bound back to screen widgets when the event handling terminates ||

==== 3.3.3.2 The @Create Annotation====

This annotation can be used to simplify the code for Controllers. It only can be used inside a controller class and it automatically creates an object (according with field type) and initialize the field with this value.

This creation is done by a call to GWT.create method, assuring that any generator eventually associated with the requested type will be called correctly.

The code showed in sections [UserManual#Access_Screen_Widgets Access Screen Widgets], [UserManual#Communication_Between_Screens Communication Between Screens], [UserManual#Communication_Between_Screens Communication Between Screens] and [UserManual#Block_and_Unblock Block and Unblock] could be written as:

{{{
@Controller("myNewController")
public class MyClass
{
    public static interface MyScreen extends ScreenWrapper
    {
        Button getMyButton();
        TextBox getMyBox();
    }
	
    @Create
    protected MyScreen myScreen;

    @Create
    protected MyContextWrapper context;

    @Create
    protected TestServiceAsync service;

    @Create
    protected MyControllerInvoker invoker;

    @Expose
    public void myMethod()
    {
        myScreen.getMyBox().setValue("Test");
        context.setValueTwo(new String[]{"Value One", "Value Two"});
    }
}
}}}

Note that {{{@Create}}} can handle service creation too, despite the fact that the variable type is not the same passed to {{{GWT.create}}} (in above example would be {{{TestService}}}).

You must note, however, that to a field can be created through {{{@Create}}} annotation, that field must has public or protected visibility or has a public getter and setter methods.

====3.3.3.3 Value Binding====

_*Crux*_ provides a mechanism to help you to automatically bind values between screen widgets and data objects.

You can create an value object and annotate it with {{{@ValueObject}}} annotation. Doing it, you allows _*Crux*_ to populate an object of this type with values present on screen widgets before run the event handler methods. After method execution, the screen is also updated with any change in these objects.

See the following example:

{{{
@ValueObject
public class Person implements Serializable
{
	private static final long serialVersionUID = -783134338059796761L;

	private String name;
	private String phone;
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getPhone() {
		return phone;
	}
	public void setPhone(String phone) {
		this.phone = phone;
	}
}
}}}

{{{
@Controller("myController")
public class MyClass
{
    @Create
    protected Person person;

    @Expose
    public void myMethod()
    {
    	Window.alert(person.getName());
    	person.setPhone("1234-5678");
    }
}
}}}

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux/ui/1.0" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <crux:screen useController="myController" >
	       <crux:textBox id="name" />
	       <crux:textBox id="phone" />
	       <crux:button id="myButton" text="Hello" onClick="myController.myMethod" />
	   </crux:screen>
   </body>
</html>
}}}

In the above example, the value of the "name" textBox on page will be bound to field "name" of the Person object created by controller (the same is true to "phone"). After the handler execution, the changes made in the value object will be reflected on page. 

If want, you can use the {{{@ScreenBind}}} annotation on value object field to inform _*Crux*_ which widget will be bound to this field. The above example can be changed to:

{{{
@ValueObject
public class Person implements Serializable
{
	private static final long serialVersionUID = -783134338059796761L;

	@ScreenBind("person.name")
	private String name;

	@ScreenBind("person.phone")
	private String phone;
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getPhone() {
		return phone;
	}
	public void setPhone(String phone) {
		this.phone = phone;
	}
}
}}}

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux/ui/1.0" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <crux:screen useController="myController" >
	       <crux:textBox id="person.name" />
	       <crux:textBox id="person.phone" />
	       <crux:button id="myButton" text="Hello" onClick="myController.myMethod" />
	   </crux:screen>
   </body>
</html>
}}}

You can also controll which fields of a value object must be bound to some widget screen. {{{@ValueObject}}} annotation has a boolean propertie called {{{bindWidgetByFieldName}}} (default to true). Setting this value to false make _*Crux*_ to does not bind all value object fields to widgets automatically. If you set this, you must specify for each field, the name of the widget that it will be bound (through {{{@ScreenBind}}} annotation).

See the following example:
{{{
@ValueObject(bindWidgetByFieldName=false)
public class Person implements Serializable
{
	private static final long serialVersionUID = -783134338059796761L;

	@ScreenBind("person.name")
	private String name;

	@ScreenBind
	private String phone; //will be bound to "phone" widget
	
	private String address; // will not be bound.
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getPhone() {
		return phone;
	}
	public void setPhone(String phone) {
		this.phone = phone;
	}
	public String getAddress() {
		return address;
	}
	public void setAddress(String address) {
		this.address = address;
	}
}
}}}

Any field in a value object can be bound to a widget if it:
  * is a primitive type (or a primitive wrapper);
  * is a CharSequence type (String, StringBuilder, StringBuffer, etc);
  * is a Date type (java.util.Date, java.sql.Date, java.sql.Timestamp, etc);
  * is an Enum type;
  * is any type annotated with {{{@ValueObject}}} annotation;
  * has public or protected visibility or has public getter and setter methods.

The following code shows more examples:

{{{
@ValueObject
public class Person implements Serializable
{
	private static final long serialVersionUID = -783134338059796761L;

	private String name;
	private Date birth;
	private Address address; 
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public Date getBirth() {
		return birth;
	}
	public void setBirth(String birth) {
		this.birth = birth;
	}
	public Address getAddress() {
		return address;
	}
	public void setAddress(Address address) {
		this.address = address;
	}
}
}}}

{{{
@ValueObject
public class Address implements Serializable
{
	private static final long serialVersionUID = -231134901059796145L;

	private String street;
	
	public String getStreet() {
		return street;
	}
	public void setStreet(String street) {
		this.street = street;
	}
}
}}}

If you want to disable the automatic value binding mechanism to a specific controller, you can set the {{{@Controller}}} property {{{autoBind}}} to false. You can, later, control the value object and screen updates through methods {{{Screen.updateScreen(controller)}}} and
{{{Screen.updateController(controller)}}}. See the following example:

{{{
@Controller(value="myController", autoBind=false)
public class MyClass
{
    @Create
    protected Person person;

    @Expose
    public void myMethod()
    {
    	Screen.updateController(this);
    	Window.alert(person.getName());
    	person.setPhone("1234-5678");
    	Screen.updateScreen(this);
    }
}
}}}

==== 3.3.3.4 Using Controllers on Screen====

To inform that a controller will be used on a screen, you must explicity "import" it using the {{{_usecontroller}}} (or {{{{useController}}}, with HtmlTags Plugin).

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux/ui/1.0" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <crux:screen useController="myController, myOtherController" >
	   </crux:screen>
   </body>
</html>
}}}

It is necessary for performance reasons.

However, if you want that a controller be imported in every screen you have, you can put an annotation {{{@Global}}} in the Controller class.

{{{
@Global
@Controller("myController")
public class MyClass
{
       // code here
}
}}}

That will allow this controller methods to be called even if no {{{useController}}} declaration is present on your screen.

==== 3.3.3.5 Comunication Between Controllers====

In section [UserManual#Communication_Between_Screens Communication Between Screens] we show how you can, from a controller, to invoke methods on another controller. Now we will see the details associated with the methods of those controllers.

The first point is that you must explicity inform _*Crux*_ that an event handler can be called from out of the current page (by another document). To do this, you must put an annotation {{{@ExposeOutOfModule}}} on the method you want to expose.

{{{
@Controller("myController")
public class MyClass
{
    @ExposeOutOfModule
    public void myMethod()
    {
       // code here
    }
}
}}}

Now, other pages can call this method through {{{Screen.invokeControllerOn<?>()}}} methods.

For calls to {{{Screen.invokeControllerOnSelf()}}} the handler does not need to be exposed to out of module. You can call a handler exposed only with {{{@Expose}}} annotation.

So we can talk about two kinds of controller methods invocation. One remote and one local. Remote calls are those made to another pages (top, parent, opener, etc) and local are made to the same page (self).

An event handler for calls made through screen invoker methods, can receive an {{{InvokeControllerEvent}}} parameter. This class provides a method to access values passed as argument in method invocation.

See the example:

{{{
   ...
   Window.alert(Screen.invokeControllerOnTop("myController.hello","Thiago"));
   Window.alert(Screen.invokeControllerOnSelf("myController.helloLocal","Thiago"));
   Window.alert(Screen.invokeControllerOnSelf("myController.parametersExample",new Object[]{new Integer(123), "Thiago", new Boolean(true)}));
   ...
}}}

or 

{{{
   ...
   Window.alert(myControllerInvoker.helloOnTop("Thiago"));
   Window.alert(myControllerInvoker.helloLocalOnSelf("Thiago"));
   Window.alert(myControllerInvoker.parametersExample(1234, "Thiago", true));
   ...
}}}

{{{
@Controller("myController")
public class MyClass
{
    @ExposeOutOfModule
    public String hello(InvokeControllerEvent event)
    {
       String param = event.getParameter(String.class);
       return "Hello "+param;
    }

    @Expose
    public String helloLocal(InvokeControllerEvent event)
    {
       String param = event.getParameter(String.class);
       return "Hello "+param;
    }

    @ExposeOutOfModule
    public String parametersExample(InvokeControllerEvent event)
    {
       if (event.getParameterCount() == 3)
       {
          int param0 = event.getParameter(0, Integer.class);
          String param1 = event.getParameter(1, String.class);
          boolean param2 = event.getParameter(2, Boolean.class);
          return "Hello "+param0;
       }
       return null;
    }
}
}}}

===== 3.3.3.5.1 Parameter types=====

The following types are allowed as arguments to a remote call to a controller method:
  * Primitive types (or a primitive wrapper);
  * CharSequence types (String, StringBuilder, StringBuffer, etc);
  * Date types(java.util.Date, java.sql.Date, java.sql.Timestamp, etc);
  * Enum types;
  * Any type that implements the interface {{{CruxSerializable}}}.
  * Arrays of any of those types above;
  
So, if you need to pass a custom object to another page, your object class must implements the interface CruxSerializable. This interface forces your type to implement a serialize and deserialize methods.

For local calls, any type is allowed, once no serialization is needed.
  
If you define a custom serializable type, you must inform _*Crux*_ explicity that you  want to use such type in your module. You can do it declaratively using {{{_useserializer}}} attibute on screen tag, or through the method {{{ModuleComunicationSerializer.registerCruxSerializable}}}.

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux/ui/1.0" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <crux:screen useController="myController" useSerializable="mySerializableType">
	   </crux:screen>
   </body>
</html>
}}}

{{{
@SerializableName("mySerializableType")  
public class MySerializableType implements CruxSerializable
{
   ...
}
}}}

or 

{{{
   ModuleComunicationSerializer.registerCruxSerializable(MySerializableType.class.getName(), new MySerializableType());
}}}

The annotation {{{@SerializableName}}} could be used to simplify the name you write on screen tag.

== 3.4 I18N ==

_*Crux*_ supports i18n for widgets created declaratively. The native [http://code.google.com/intl/pt-BR/webtoolkit/tutorials/1.6/i18n.html GWT mechanism] is still valid.

You can use the following pattern to tell _*Crux*_ that you want to use a GWT message or a constant value in a widget tag declaration:

{{{
   "${<messageResource>.<messageEntry>}"	
}}}

For example. Supose the following messages interface:

{{{
public interface MyMessages extends Messages
{
	@DefaultMessage("my message")
	String myMessage();
}
}}} 

And the crux page that uses it:

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux/ui/1.0" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <crux:label id="label" text="${myMessages.myMessage}" />
   </body>
</html>
}}}

In the above example, the message resource name is derived from interface name. If you want to change this value, you can use the annotation {{{@Name}}} in your messages interface.

See the example:

{{{
@Name("msg")
public interface MyConstants extends Constants
{
	@DefaultStringValue("my message")
	String myMessage();
}
}}} 

{{{
   ...
       <crux:label id="label" text="${msg.myMessage}" />
   ...
}}}

== 3.5 Client-Server Communication ==

You can use [http://code.google.com/intl/pt-BR/webtoolkit/tutorials/1.6/RPC.html GWT RPC] and [http://code.google.com/intl/pt-BR/webtoolkit/tutorials/1.6/JSON.html JSON] support to communicate with server. _*Crux*_, however, adds some few features to pure GWT RPC mechanisms to turn it easier. 

With _*Crux*_, you can use a _Front Controller_. The use of this _Front Controller_ allows you to make just one mapping in your web.xml file.

In other words, you don't need to add a new servlet declaration on your GWT module definition nether on web.xml for each new service declared.
 
Other improvement is the use of the  [3.3.3.2_The_@Create_Annotation @Create annotation]. It will create the service object and set its  entry point name to point to the _Front Controller_ automatically. 
 
The following example shows all this features together:
 
{{{
package crux.examples.client.remote;

import com.google.gwt.user.client.rpc.RemoteService;

public interface GreetingService extends RemoteService
{
        public String getHelloMessage(String name);
}
}}}

{{{
public class MyController {
        @Create
        protected GreetingServiceAsync service; 
        
        @Expose
        public void sayHello() {
                service.getHelloMessage("Thiago", new AsyncCallbackAdapter<String>(this){
                                @Override
                                public void onComplete(String result){
                                   Window.alert(result);
                                }
                        }
                );
        }
}
}}}

Note that the service interface does not use the annotation [http://code.google.com/intl/pt-BR/webtoolkit/tutorials/1.6/RPC.html RemoteServiceRelativePath]. It will assume the mapping to the Front Controller. If that annotation was present, _*Crux*_ would use it to set the entry point name.

Another point to observe in the above example is the use of the abstract class {{{AsyncCallbackAdapter}}} in the place of GWT {{{AsyncCallback}}} interface.

That class does the following:
  # Implements a default error handler that alert the exception message and log it.
  # If controller autoBind for [UserManual#3.3.3.3_Value_Binding ValueObjects] is enabled, it will automatically update screen with value object properties after process the {{{onComplete()}}} method.


So, the two following approach is equivalents:

{{{
@Controller(value="myController", autoBind=true)
public class MyController {
        @Create
        protected GreetingServiceAsync service; 
        
        @Create
        protected Person aValueObject; 

        @Expose
        public void sayHello() {
                service.getHelloMessage("Thiago", new AsyncCallbackAdapter<String>(this){
                                @Override
                                public void onComplete(String result){
                                   aValueObject.setName("Thiago");
                                }
                        }
                );
        }
}
}}}

{{{
@Controller(value="myController", autoBind=false)
public class MyController {
        @Create
        protected GreetingServiceAsync service; 
        
        @Create
        protected Person aValueObject; 

        @Expose
        public void sayHello() {
                Screen.updateController(this);
                service.getHelloMessage("Thiago", new AsyncCallback<String>(this){
                                public void onSuccess(String result){
                                   aValueObject.setName("Thiago");
                                   Screen.updateScreen(this);
                                }
                                public void onFailure(Throwable e){
                                    GWT.log(e.getLocalizedMessage(), e);
                                    Window.alert(e.getLocalizedMessage());
                                    Screen.updateScreen(this);
                                }
                        }
                );
        }
}
}}}

= 4 Coding Server Side =

== 4.1 Writing Server Services ==

As wed said in section [UserManual#3.5_Client-Server_Communication Client-Server Communication], _*Crux*_ supports the [http://code.google.com/intl/pt-BR/webtoolkit/tutorials/1.6/RPC.html GWT RPC] mechanism with some few features to turn it easier.

At server side, the main difference for GWT is that your service implementation class does not need to extend {{{RemoteServiceServlet}}}. It 
just needs to implement the service interface.

{{{
public interface GreetingService extends RemoteService{
	public String getHelloMessage(String name);
}
}}}

{{{
public class GreetingServiceImpl implements GreetingService{
   public String getHelloMessage(String name){
      return "Server says: Hello, " + name + "!'";
   }
}
}}}

To find out which implementation will be used for a given service interface, _*Crux*_ will search (using javassist) for classes that implements that interface and use the first one found.

This behaviour can be changed, as showed in section [UserManual#4.3.2.5_controllerFactory controllerFactory].

If your service class needs to access the request, response or session, it can implements the interfaces RequestAware, ResponseAware or SessionAware, as in the following example:

{{{
public class GreetingServiceImpl implements GreetingService, RequestAware, ResponseAware{
   private HttpServletRequest request;
   private HttpServletResponse response;
   	
   public void setRequest(HttpServletRequest request){
      this.request = request;
   }
   public void setResponse(HttpServletResponse response){
      this.response = response;
   }
   ...   
}
}}}
== 4.2 I18N ==


== 4.3 Setup ==

=== 4.3.1 Web.xml ===
To setup the _*Crux* Front Controller_, showed in [3.5_Client-Server_Communication previous section], you must add the following lines to your web.xml file:

{{{
	<servlet>
		<servlet-name>remoteServiceServlet</servlet-name>
		<servlet-class>
			br.com.sysmap.crux.core.server.dispatch.RemoteServiceServlet
		</servlet-class>
	</servlet>

	<servlet-mapping>
		<servlet-name>remoteServiceServlet</servlet-name>
		<url-pattern>*.rpc</url-pattern>
	</servlet-mapping>
}}}

There are some other configurations you will need to do to run your application in [FAQ#_Crux_Design development environment]: 

{{{
	<filter>
		<display-name>CruxFilter</display-name>
		<filter-name>CruxFilter</filter-name>
		<filter-class>br.com.sysmap.crux.core.server.CruxFilter</filter-class>
	</filter>
	<filter-mapping>
		<filter-name>CruxFilter</filter-name>
		<url-pattern>*.html</url-pattern>
	</filter-mapping>
}}}

The above lines is needed by _*Crux*_ [http://code.google.com/intl/pt-BR/webtoolkit/doc/1.6/DevGuideCodingBasics.html#DevGuideDeferredBinding Generators] to find out which module is beeing compiled. This is used for better performance (see [FAQ#Performance this] for more information). Because that information is used only for compilation, it just need to be present in development environment.

If you plan to use the [HtmlTags] plugin, you need to add this lines too:

{{{
<filter>
		<display-name>HtmlTagsFilter</display-name>
		<filter-name>HtmlTagsFilter</filter-name>
		<filter-class>br.com.sysmap.crux.tools.htmltags.filter.HtmlTagsFilter</filter-class>
		<init-param>
			<param-name>outputCharset</param-name>
			<param-value>ISO-8859-1</param-value>
		</init-param>
	</filter>
	<filter-mapping>
		<filter-name>HtmlTagsFilter</filter-name>
		<url-pattern>*.html</url-pattern>
	</filter-mapping>
}}}   

This filter is used to transform your _.crux.xml_ files in pure _html_ files. This process is only done in development. In a production environment, your application can access the generated version of the page directly. 

The two above filters, that is used only for development, does nothing if used in a production environment, generating no overhead. They are removed by the ant task generated for deploy your project (if you are using the [_*Crux* Project Generator_]).

You can add an optional listener called InitializerListener to initialize some _*Crux*_ resources to turn the first call to application faster.

{{{
   <listener>
      <listener-class>br.com.sysmap.crux.core.server.InitializerListener</listener-class>
   </listener>
}}}
=== 4.3.2 Crux.properties ===

_*Crux*_ tries to read a file called {{{Crux.properties}}} that can be put (optionaly) in any place under your classpath to change some default behavior of the framework.

The following properties can be set in this file:

|| *Property* || *Description* || *Default Value* ||
||wrapSiblingWidgets||If false, widgets created declarativelly under the same parent<br> has no guarantee of order||true||
||localeResolver||Class used by _*Crux*_ to resolve locale for user at the server side||br.com.sysmap.crux.core.i18n.LocaleResolverImpl||
||screenResourceResolver||Class used by _*Crux*_ to retrieve the screen page files||br.com.sysmap.crux.core.rebind.screen.ScreenResourceResolverImpl||
||classPathResolver||Class used by _*Crux*_ to resolve classpath files||br.com.sysmap.crux.core.server.classpath.ClassPathResolverImpl||
||controllerFactory||Class used by _*Crux*_ to instantiate controller classes||br.com.sysmap.crux.core.server.dispatch.ControllerFactoryImpl||

==== 4.3.2.1 wrapSiblingWidgets ====

To enable _*Crux*_ to do very significant improvements in screen creation performance, _*Crux*_ will need that all of your widgets are orphan child of their parents.

The property {{{wrapSiblingWidgets}}} will automatically create an empty {{{<span>}}} tag around each widget that does not follow this restriction. 

See the following example:

{{{
   ...
   <body>
       <crux:textBox id="box1" />
       <crux:textBox id="box2" />
       <div>
	       <crux:textBox id="box3" />
       </div>
   </body>
   ...
}}}

That will be transformed to the following DOM elements:

{{{
   ...
   <body>
       <span><input type="text" id="box1" ... /></span>
       <span><input type="text" id="box2" ... /></span>
       <div>
	       <input type="text" id="box3" ... />
       </div>
   </body>
   ...
}}}

If you want, you can disable this mechanism setting this property to false. In such a case, you will need to care to put your widgets in panels, or in other html tags alone, or else, _*Crux*_ will not guarantee the order of the sibling widgets.

If this this propertyis disabled, the previous example can build the following sequence of elements into the DOM:
{{{
   ...
   <body>
       <input type="text" id="box2" ... /></span>
       <div>
	       <input type="text" id="box3" ... />
       </div>
       <input type="text" id="box1" ... />
   </body>
   ...
}}}

In that case, the best would be refactory this to:
{{{
   ...
   <body>
       <crux:flowPanel id="panel1">   
          <crux:textBox id="box1" />
          <crux:textBox id="box2" />
          <div>
	         <crux:textBox id="box3" />
          </div>
       </crux:flowPanel>   
   </body>
   ...
}}}

==== 4.3.2.2 localeResolver ====

==== 4.3.2.3 screenResourceResolver ====

==== 4.3.2.4 classPathResolver ====

==== 4.3.2.5 controllerFactory ====

= 5 Extending and Customizing =