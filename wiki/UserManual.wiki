= 1 Introduction =

= 2 Quick Start=

== 2.1 Install ==

== 2.2 Sample Application ==

== 2.3 Create an Application ==

= 3 Coding Client Side =

_*Crux*_ applications are basically GWT applications. It means that you must attempt to all GWT restrictions in terms of source code limitations an project structure directives.

If you are not familiar with GWT, please consult its [http://code.google.com/intl/pt-BR/webtoolkit/ documentation] first.

Your modules must inherits _*br.com.sysmap.crux.core.Crux.gwt.xml*_. You don't need to specify an EntryPoint, because _*Crux*_ defines a basic one that starts a parser on page document to replace the marker `<span>` tags to widgets. 

If you need to create a new EntryPoint, your class must override the _*Crux*_ EntryPoint ({{{br.com.sysmap.crux.core.client.JSEngine}}}) and call super on your onModuleLoad() method.

The following example shows a module that can use any widget provided by default distribution of Crux:
{{{
<module rename-to='cruxtest'>
	<inherits name='br.com.sysmap.crux.core.Crux'/>
	<inherits name='br.com.sysmap.crux.basic.CruxBasicWidgets'/>
	<inherits name='br.com.sysmap.crux.advanced.CruxAdvancedWidgets'/>
</module>
}}}

The code above creates a module that inherits the _*Crux*_ core and the two sets of widgets that compose the default distribution. The BasicWidgets set contains all widgets that is distributed directly with GWT. The Advanced set contains some complex widgets like MaskedTexBox, multi-frame capable dialogs etc.

== 3.1 Building User Interface ==

Any GWT widget can be used in user interface construction. Default _*Crux*_ distribution supports the use of any widget included in the [http://code.google.com/intl/pt-BR/webtoolkit/doc/1.6/DevGuideUserInterface.html GWT default distribution]. To use any of those widgets, you must ensure that the file crux-basicwidgets.jar is present in the WEB-INF/lib folder of your application. Adavanced widgets are also availabe through crux-advancedwidgets.jar. Consult the [ComponentDeveloperManual Component Developer Manual] for informations about how to use custom widgets with _*Crux*_.

To add widgets to your pages, you can use one of these three methods:
  # Declare a _`<span>`_ tag with an attribute `_`type to inform which widget you want to add to the page.
  # Use _*HtmlTags*_ tool to build a page as a XML file and use some XSDs to enable auto completition on your favorite editor.
  # Create programatically a widget exactly as you already do using GWT alone. 

=== 3.1.1 Writing HTML Pages===
The following code is an example of the first method:
{{{
<html>
   <head>
       <script language='javascript' src='cruxtest/cruxtest.nocache.js'></script>
   </head>
   <body>
       <span id='myBox' _type='textBox' />
       <span id='myButton' _type='button' _text='Hello' _onclick='clientHandler.helloWorld' />
   </body>
</html>
}}} 

You can consult the following [Widgets#Basic_Widgets table] to verify the type for default GWT widgets.



=== 3.1.2 Writing XML Pages===
Now, you can see an example of the second method:
{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux/ui/1.0" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <crux:textBox id="myBox" />
       <crux:button id="myButton" text="Hello" onClick="clientHandler.helloWorld" />
   </body>
</html>
}}} 

If you decide to use this approach, you must attempt to:
  # Your files must have the extension *_.crux.xml_*.
  # In order to enable auto completition, you need to configure your IDE to point to the following XSD files:
    * [xhtml.xsd xhtml.xsd]
    * [crux-basicwidgets.xsd crux-basicwidgets.xsd]
    * [crux-advancedwidgets.xsd crux-advancedwidgets.xsd]
  # Configure the HtmlTagsFilter in your web.xml files as following:
{{{
<filter>
   <display-name>HtmlTagsFilter</display-name>
   <filter-name>HtmlTagsFilter</filter-name>
   <filter-class>br.com.sysmap.crux.tools.htmltags.filter.HtmlTagsFilter</filter-class>
   <init-param>
      <param-name>outputCharset</param-name>
      <param-value>ISO-8859-1</param-value>
   </init-param>
</filter>
<filter-mapping>
   <filter-name>HtmlTagsFilter</filter-name>
   <url-pattern>*.html</url-pattern>
</filter-mapping>
}}}

Note that if you use the [UserManual#CruxProjectGenerator Crux Project Generator], it will already configure the filter for you.

This filter will intercept the requests to transform your *_.crux.xml_* files in *_.html_* files that uses _`<span>`_ tags, exactly as the page showed in the first method. It just need to be done in a development scenario. Before you put your application in production, you compile your code (see [UserManual#Compilation compilation]) and the transformation is done only at this moment.

If the filter is used in a production scenario, it will just do nothing. 

=== 3.1.3 Creating Widgets Programatically===

You can create widgets exactly as you create using GWT directly. 

You can add an EventHandler to be called when the screen is loaded (see [UserManual#Managing_Events Managing Events] to more details about events). 

Inside your EventHandler, you can build Widgets as in the following example:
{{{
   ...
   Button myButton = new Button();
   myButton.addClickHandler(new ClickHandler(){
      public void onClick(ClickEvent event)
      {
          Window.alert("hello");
      }
   });
   ...
}}}

== 3.2 Screen ==

_*Crux*_ creates an abstraction over the page that is called *_Screen_*. Declaratively, you can refer to it using a `<span>` with `_`type="screen":

{{{
<html>
   <head>
       <script language='javascript' src='cruxtest/cruxtest.nocache.js'></script>
   </head>
   <body>
       <span _type='screen' _onclose='clientHandler.onClose' _usecontroller="clientHandler">
	       <span id='myBox' _type='textBox' />
	       <span id='myButton' _type='button' _text='Hello' _onclick='clientHandler.helloWorld' />
       </span>
   </body>
</html>
}}}

If you are using XML files with HTMLTags plugin, you can write:

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux/ui/1.0" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <crux:screen onClose='clientHandler.onClose' onLoad='clientHandler.onLoad' useController="clientHandler" />
       <crux:textBox id="myBox" />
       <crux:button id="myButton" text="Hello" onClick="clientHandler.helloWorld" />
   </body>
</html>
}}}

The screen can be retrieve programatically by a call to the static method {{{Screen.get()}}}.
Through Screen, you can:
  # Access any widget created decaratively on pages.
  # Add handlers to Window events, like load, close or resize.
  # Communicate with other screens to, for example, exchange data between _*Crux*_ pages in different frames or windows of the same application.
  # Control the history without need to add a hidden frame directly on the page.
  # Block and unblobck the user intercation with the page.

=== 3.2.1 Access Screen Widgets ===

To access screen widgets, you can use the static method {{{Screen.get(screenId)}}}.

{{{
	Button myButton = (Button)Screen.get("myButton");
	or
	Button myButton = Screen.get("myButton", Button.class);
}}}

You can also create an interface to access your widgets on screen. Your interface must extends the interface ScreenWrapper and the methods must follow the pattern: {{{<widgetType> get<WidgetID>()}}}. See the example:
{{{
@Controller("myController")
public class MyClass
{
	public static interface MyScreen extends ScreenWrapper
	{
		Button getMyButton();
		TextBox getMyBox();
	}
	
	protected myScreen = GWT.create(MyScreen.class);

	public void myMethod()
	{
		myScreen.getMyBox().setValue("Test");
	}
}
}}}

We recomend that you create wrappers for screens, that is most elegant and avoid mismatches on typing widgets ids as strings all over the code.

=== 3.2.2 Screen Events ===

_*Crux*_ Screen support the following events:
|| *Event* || *Description* ||
||Load||Called when page loads. It is fired after the screen's building process is completed||
||Close||Called when page is colsed||
||Closing||Called before close the page||
||Resize||Called on page resize||
||HistoryChanged||Called when back button is pressed||

=== 3.2.3 Communication between Screens===

Using some static methods on Screen class, it is possible to invoke operations on other _*Crux*_ screens running in different frames or windows.

The following example shows how this can be done:

{{{
	Screen.invokeControllerOnTop("topController.method", new MyParameterClass());
}}}

That code will call the method "method" on controller identified by "topController" on the top page. Consult the section [UserManual#Managing_Events Managing Events] for more details about how this call is processed.

The following table shows the methods that allows calls on others screens:

|| *Method* || *Description* ||
||invokeControllerOnParent||call a controller on parent page||
||invokeControllerOnOpener||call a controller on opener page||
||invokeControllerOnAbsoluteTop||call a controller on top of the first opener page||
||invokeControllerOnTop||call a controller on top page||
||invokeControllerOnSelf||call a controller on self||


You can also share information between _*Crux*_ screens using a common context to read and write variables.

The _*Crux*_ Context is a common area where you can put and read values associating them with a key.

To turn easier the access to context information, you can define an interface that extends the interface {{{Context}}}. Its methods must follow the pattern: {{{<valueType> get<valueKey>()}}} or {{{void set<valueKey>(valueType)}}}. See the example:

{{{
@Controller("myController")
public class MyClass
{
	public static interface MyContextWrapper extends Context
	{
		Double getValueOne();
		String[] getValueTwo();
		void setValueTwo(String[] value);
	}
	
	protected MyContextWrapper = GWT.create(MyContextWrapper.class);

	public void myMethod()
	{
		Screen.createContext();
		MyContextWrapper context = Screen.getContext(MyContextWrapper.class);
		context.setValueTwo(new String[]{"Value One", "Value Two"});
		Window.alert(context.getValueTwo()[0]);
	}
}
}}}

If you pass null as argument for a setter method of a Context Wrapper object, it will remove that value from context. Example:

{{{
	context.setValueTwo(null);
}}}

Note that you can have more than one Context Wrapper. Different modules can use different wrappers if you want. However, the area where context information is written is unique.

Screen class has the following static methods to support Context management:

|| *Method* || *Description* ||
||createContext||Initialize the context. It just need to be called once in one of the modules that is sharing informations.||
||getContext||creates a wrapper object to access the context||
||clearContext||remove all context entries||

Behind the scenes, Context is managed by a ContextHandler Object. It is provided two implementations for this interface:
|| *Handler* || *Description* || 
||CookieContextHandler||Use cookies to store values||
||TopContextHandler||Store values in a HashMap located on top of the first opener window||

The default implementation is CookieContextHandler. However, each one has pros and cons.

*TopContextHandler* is faster and does not leave data after the application is closed. It is not possible to have dirty read, because the context area is created only when used for the first time. However, in a multi window application, the context data is lost if top window is closed.

*CookieContextHandler* never loses data if a window is closed. However, you must ensure that you call the method {{{Screen.createContext()}}} in your application to avoid dirty reads (cookies can contains old values from a previous execution).

If you desire, you can add the following lines to your module config file to change the default context behaviour:
{{{
	<replace-with class="br.com.sysmap.crux.core.client.context.TopContextHandler">
		<when-type-assignable class="br.com.sysmap.crux.core.client.context.ContextHandler" />
	</replace-with>			
}}}


=== 3.2.4 Control History ===

Screen provides a simple mechanism to manage history. Using the static method {{{Screen.addToHistory(String token)}}} you can create a history token (exactly as [http://code.google.com/docreader/#p=google-web-toolkit-doc-1-5&s=google-web-toolkit-doc-1-5&t=DevGuideHistory GWT tokens]). To handle the changes on history, you can add a handler to HistoryChanged events, as you can see in the next example:

{{{
	// To put a token on history
	Screen.addToHistory("link1Clicked");
}}}

{{{
	// To add a HistoryChanged Handler
	Screen.addHistoryChangedHandler(new addValueChangeHandler<String>(){
		public void onValueChange(ValueChangeEvent<String> event)
		{
			Window.alert(event.getValue());
		}
	});
}}}

or Declaratively:

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux/ui/1.0" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <crux:screen useController="clientHandler" onClose='clientHandler.onClose' onLoad='clientHandler.onLoad' onHistoryChanged='clientHandler.onHistoryChanged' />
   </body>
</html>
}}}

Note that you don't need here to add any iFrame to your host page, as in pure GWT.

=== 3.2.5 Block and Unblock ===

You can block and unblock the user interaction with the page using the static methods {{{Screen.blockToUser()}}} e {{{Screen.unblockToUser()}}}. See the following example:

{{{
  ...
   protected TestServiceAsync service = (TestServiceAsync) GWT.create(TestService.class);

   public void helloWorld()
   {
        Screen.blockToUser();
        service.hello(new AsyncCallback<String>()
        {
                public void onSuccess(String s) 
                {
                        Screen.unblockToUser();
                        Window.alert(s);
                }
                public void onFailure(Throwable e) 
                {
                        Screen.unblockToUser();
                        Window.alert(e.getMessage());
                }
        });
   }   
   ...
}}} 

== 3.3 Managing Events ==

It's possible to add event handlers:
  # Declaratively.
  # Programatically.

=== 3.3.1 Add Event Declaratively===
To add an event declaratively, you must create a [UserManual#Controller Controller] and give it a name.

If you are creating your pages without the [HtmlTags plugin] support, you can declare attributes in the {{{<span>}}} element that define the widget properties following the pattern {{{_on<eventName> = "<controllerName>.<methodName>"}}}.

{{{
<html>
   <head>
       <script language='javascript' src='cruxtest/cruxtest.nocache.js'></script>
   </head>
   <body>
       <span _type='screen' _onclose='clientHandler.onClose' _usecontroller='clientHandler'>
	       <span id='myBox' _type='textBox' _onchange='clientHandler.helloWorld'/>
	       <span id='myButton' _type='button' _onclick='clientHandler.helloWorld' />
       </span>
   </body>
</html>
}}}

Note that you must also "import" your controller through the attribute {{{_usecontroller}}} of the screen's tag.

If you decide to use the HtmlTags Plugin, you can write:

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux/ui/1.0" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <crux:screen onClose='clientHandler.onClose' useController="clientHandler" >
	       <crux:textBox id="myBox" />
	       <crux:button id="myButton" text="Hello" onClick="clientHandler.helloWorld" />
	   </crux:screen>
   </body>
</html>
}}}

=== 3.3.2 Add Event Programatically===

You can still use the default GWT mechanism to add handlers for events programatically, like:

{{{
   ...
   Button myButton = new Button();
   myButton.addClickHandler(new ClickHandler(){
      public void onClick(ClickEvent event)
      {
          Window.alert("hello");
      }
   });
   ...
}}}

The only point to observe here is that you need to put this code in some controller method that is called declaratively, unless you has overwriten the _*Crux*_ EntryPoint and call it directly from there.

=== 3.3.3 Controller===

== I18N ==

== Client-Server Communication ==

= Coding Server Side =

== I18N ==

= Extending and Customizing =