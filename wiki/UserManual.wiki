#labels Featured,Phase-Implementation
= Crux 3.0.0 =

= 1 Introduction =

_*Crux*_ applications are basically GWT applications. It means you must attempt to all GWT restrictions in terms of source code limitations and project structure directives.
If you are not familiar with GWT, please consult its [http://code.google.com/intl/pt-BR/webtoolkit/ documentation] first.

This documentation will show you, in a detailed and gradual way, how to use the _*Crux*_ framework, by exploring and exemplifying its features. Here you will also learn the concepts behind the code and understand how does _*Crux*_ work internally. In order to easy follow this documentation you will need:
  * A [http://java.sun.com/javase/downloads/index.jsp Java SE Development Kit (JDK)], version 1.5 or higher (we recommend 1.6);
  * An [http://www.eclipse.org/downloads/packages/ Eclipse] IDE;

To see an example application using _*Crux*_, take a look at the [http://crux-showcase.appspot.com/ Showcase].
== 1.1 _Crux_ and GWT==

_*Crux*_ is built over GWT and support all of its features.
Current _*Crux*_ version uses GWT 2.0.

= 2 Quick Start=

== 2.1 Install ==

  * Download the latest _*Crux*_ release [http://code.google.com/p/crux-framework/downloads/list here];
  * Unzip the archive into a folder you want;
  * Be sure that your default JVM is the version 1.6 or higher. It is necessary to execute the _*Crux*_ installer (in runtime, Crux projects run fine with Java 1.5);
  * Execute the {{{start.cmd}}} or {{{start.sh}}} file, according to your operating system;
  * The _*Crux QuickStart*_ tool will start, opened in your default web browser:
  
  http://crux-framework.googlecode.com/svn/wiki/images/quickstart-begin.gif
  
  * Click the {{{Generate New Crux Application}}} button and follow the instructions. At the end of the wizard, an Eclipse project will be generated for you.
  * Import the freshly generated project into your Eclipse IDE, and you will get something like this:
  
  http://crux-framework.googlecode.com/svn/wiki/images/generated-project.gif
   
  * Run the {{{<your project name>.launch}}} file, located at the project root folder;
  * If everything's gone OK, the GWT DevMode console will appear, and your first application will look like this:
  
  http://crux-framework.googlecode.com/svn/wiki/images/generated-project-running.gif
  	  
== 2.2 Environment Configuration ==

To enable auto-completion on your _*Crux*_ pages you must add the project catalog to your Eclipse. This project catalog is located under the folder {{{xsd}}} ({{{crux-catalog.xml}}}) and includes information about all the _*Crux*_ widget libraries that are present in your project classpath.

To add the catalog file to your Eclipse catalogs list, just go to

{{{
   Window->Preferences...->XML Catalog
}}}

Then, select {{{User Specified Entries}}} and choose {{{Add...}}}. Choose {{{Next Catalog}}} and inform the path to the {{{crux-catalog.xml}}} file.

== 2.3 Sample Application ==

Here we will explore the application generated in the previous section, explaining each single part of it.

  * The {{{war}}} folder is the root context of your application and contains: 
    * a WEB-INF folder, compliant with JEE specifications, where you will find:
      * the {{{web.xml}}} file (more details at [UserManual#4.3.1_Web.xml 4.3.1 Web.xml]);
      * the {{{lib}}} folder, which stores all _*Crux*_ jar files your need at development time (more details at section [UserManual#4.3_Setup Setup]);
      * a {{{classes}}} folder, which is the output for java compilation;
    * a {{{<the name you gave>.crux.xml}}} file: the _welcome file_ of your application (more about _*Crux*_ XML files at [UserManual#3.1.2_Writing_XML_Pages 3.1.2 Writing XML Pages];
  * the {{{build}}} folder, containing:
    * a {{{lib}}} folder, containing the files needed by _*Crux*_ compilation;
    * a {{{build.xml}}} ant file, which defines the following tasks:
      * *dist*: generates the war file for deployment;
      * *compile-scripts*: invokes the _*Crux*_ compilation, generating the static files that can be tested in browsers;
      * *fast-compile-scripts*: almost equals to the previous, but faster, because generates non-optimal compiled files, by calling GWT compiler with the {{{-draftCompile}}} parameter;
      * *generate-schemas*: generates all XSD files you need to auto-complete your XML pages code.
  * the {{{src}}} folder, containing the source files:
    * {{{<the name you gave the module>.gwt.xml}}} - a GWT module which extends _*Crux*_ modules (like shown at [UserManual#3_Coding_Client_Side Coding Client Side]);
    * {{{<the same module package>.client.controller.MyController.java}}} - a client-side controller for the welcome page (see [UserManual#3.3.3_Controller 3.3.3 Controller]);
    * {{{<the same module package>.client.remote.GreetingService.java}}} -  a client-side business interface;
    * {{{<the same module package>.client.remote.GreetingServiceAsync.java}}} -  a client-side asynchronous interface for accessing the server;
    * {{{<the same module package>.server.GreetingServiceImpl.java}}} -  the server-side business class;
  for more about last three items, see the [UserManual#4.1_Writing_Server-Side_Code 4.1 Writing Server-Side Code] section.     
      
= 3 Coding Client Side =

Your modules must inherit _*br.com.sysmap.crux.core.Crux*_. You don't need to specify an EntryPoint, because _*Crux*_ defines a basic one that loads its engine. 

The following example shows a typical module which can use all _*Crux*_ features:
{{{
<module rename-to='mymodule'>
	<inherits name='br.com.sysmap.crux.core.Crux'/>
	<inherits name='br.com.sysmap.crux.gwt.CruxGWTWidgets'/>
	<inherits name='br.com.sysmap.crux.widgets.CruxWidgets'/>
</module>
}}}

The code above creates a module that inherits the _*Crux*_ core and the two sets of widgets that compose the default distribution. 
  * The [Widgets#1_GWT_Widgets CruxGWTWidgets]  set contains all widgets that are distributed directly with GWT. It's packaged in the {{{crux-gwt-widgets.jar}}} file. 
  * The  [Widgets#2_Crux_Widgets CruxWidgets] set contains some complex widgets like MaskedTexBox, multi-frame capable dialogs, etc. It's packaged in the {{{crux-widgets.jar}}} file.

== 3.1 Building User Interface ==

Any GWT widget can be used in user interface construction. Consult the [WidgetDeveloperManual Widget Developer Manual] for information about how to use custom widgets with _*Crux*_.

To add widgets to your pages, you can use these methods:
  # Create a page as a XML file and use some XSDs to enable auto completion on your favorite editor.
  # Programmatically instantiate widgets, exactly as you already do using with pure GWT. 

=== 3.1.1 Pages as XML Files===
{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:gwt="http://www.sysmap.com.br/crux/gwt" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <gwt:textBox id="myBox" />
       <gwt:button id="myButton" text="Hello" onClick="clientHandler.helloWorld" />
   </body>
</html>
}}} 

You must attempt to:
  * Your files must have the extension *_.crux.xml_*.
  * In order to enable auto completion, you will need to configure your IDE to point to all XSD files generated by the [UserManual#5.1_Schema_Generator Schema Generator]:
    If you are using an Eclipse based IDE, it can be done at the menu *Window -> Preferences -> XML -> XML Catalog* 

  * Configure the DeclarativeUIFilter in your web.xml files as following (if you use the [UserManual#2_Quick_Start Crux Quick Start] to generate your project, it will already configure the filter for you):
{{{
<filter>
   <display-name>DeclarativeUIFilter</display-name>
   <filter-name>DeclarativeUIFilter</filter-name>
   <filter-class>br.com.sysmap.crux.core.declarativeui.filter.DeclarativeUIFilter</filter-class>
   <init-param>
      <param-name>outputCharset</param-name>
      <param-value>ISO-8859-1</param-value>
   </init-param>
</filter>
<filter-mapping>
   <filter-name>DeclarativeUIFilter</filter-name>
   <url-pattern>*.html</url-pattern>
</filter-mapping>
}}}

The *.crux.xml* files are used to make development easier. When you generate the final application distribution file, the _*Crux*_ compiler translate those pages into *.html* pages. See [UserManual#5.3_Crux_Compiler Crux Compiler] for more information.

It means that you can, for example, create a page called {{{index.crux.xml}}}, but the url you must pass to the browser will refer to {{{index.html}}}. 

=== 3.1.2 Instantiating Widgets Programmatically===

You can instantiate widgets exactly as you do using pure GWT. 
{{{
   ...
   Button myButton = new Button();
   myButton.addClickHandler(new ClickHandler(){
      public void onClick(ClickEvent event)
      {
          Window.alert("hello");
      }
   });
   ...
}}}

== 3.2 Screen ==

_*Crux*_ creates an abstraction over the page that is called *_Screen_*. Declaratively, you can refer to it using a `<screen>` tag:

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux" 
      xmlns:gwt="http://www.sysmap.com.br/crux/gwt" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <crux:screen onClose="clientHandler.onClose" onLoad="clientHandler.onLoad" useController="clientHandler" />
       <gwt:textBox id="myBox" />
       <gwt:button id="myButton" text="Hello" onClick="clientHandler.helloWorld" />
   </body>
</html>
}}}

The screen can be retrieved programmatically by a call to the static method {{{Screen.get()}}}.
Through Screen, you can:
  # Access any widget created declaratively on pages;
  # Add handlers to Window events, like {{{load}}}, {{{close}}} or {{{resize}}};
  # Manage the browser's history, without need to add a hidden frame directly on the page;
  # Block and unblock the user interaction with the page;
  # Create data sources programmatically;
  # Access some other information, like the user's locale.


=== 3.2.1 Accessing Screen Widgets ===

To access screen widgets, you can use the static method {{{Screen.get(screenId)}}}.

{{{
	Button myButton = (Button)Screen.get("myButton");
	or
	Button myButton = Screen.get("myButton", Button.class);
}}}

You can also create an interface to access your widgets on screen. Your interface must extend the interface ScreenWrapper and the methods must follow the pattern: {{{<widgetType> get<WidgetID>()}}}. See the example:
{{{
@Controller("myController")
public class MyClass
{
	public static interface MyScreen extends ScreenWrapper
	{
		Button getMyButton();
		TextBox getMyBox();
	}
	
	@Create
	protected MyScreen myScreen;

	public void myMethod()
	{
		myScreen.getMyBox().setValue("Test");
	}
}
}}}

We recommend you to write wrappers for your screens because it is more elegant and avoids mismatches and the spread of the widgets' IDs throughout your code.

=== 3.2.2 Screen Events ===

_*Crux*_ Screen support the following events:
|| *Event* || *Description* ||
||Load||Called when page loads. It is fired after the screen's building process is completed||
||Close||Called when page is closed||
||Closing||Called before close the page||
||Resize||Called on page resize||
||HistoryChanged||Called when back button is pressed||


=== 3.2.3 Shared Context===

The _*Crux*_ Context is a common area where you can store and retrieve data. Each data entry is associated with a key. You can think this mechanism like a web session, but residing on the client side of the application. It means you can store not only general-use information, but user-related data too.

Behind the scenes, Crux contexts are nothing but cookies. It means you should not trust in its contents when executing security-sensible operations, like verifying authenticity or permissions of your user, for example.

The data you store in a Context are visible to any Window on your application, no matter if it is a Popup, a Tab Page, or an IFrame. So, it is a very useful mechanism to share data between different HTML documents.

=== 3.2.3.1 Using Contexts===

To turn easier the access to context information, you can define an interface that extends the interface {{{Context}}}. Its methods must follow the pattern: {{{<valueType> get<valueKey>()}}} or {{{void set<valueKey>(valueType)}}}. See the example:

{{{
public interface MyContextWrapper extends Context
{
	Double getValueOne();
	String[] getValueTwo();
	void setValueTwo(String[] value);
}
}}}


{{{
@Controller("myController")
public class MyClass
{	
    @Create
    protected MyContextWrapper context;

	public void myMethod()
	{
		context.setValueTwo(new String[]{"Value One", "Value Two"});
		Window.alert(context.getValueTwo()[0]);
	}
}
}}}

If you pass null as argument for a setter method of a Context Wrapper object, it will remove that value from context. Example:

{{{
	context.setValueTwo(null);
}}}

Note that you can have more than one Context Wrapper. Different modules can use different wrappers if you want. However, the area where context information is written is unique.
It's important to advice that you must initialize the context before using it. This can be done this way:

{{{
Screen.createContext();
}}}

If you call {{{Screen.createContext()}}} more than once, you will erase the context and create a new one. When we talk about calling it only once, we mean once per user session. For example, you may call it only the user logs in your application successfully.

Screen class has the following static methods to support Context management:

|| *Method* || *Description* ||
||createContext||Initializes the context. It just needs to be called once in one of the modules that are sharing information.||
||clearContext||Removes all context entries||


=== 3.2.4 Control History ===

Screen provides a simple mechanism to manage history. Using the static method {{{Screen.addToHistory(String token)}}} you can create a history token (exactly as [http://code.google.com/docreader/#p=google-web-toolkit-doc-1-5&s=google-web-toolkit-doc-1-5&t=DevGuideHistory GWT tokens]). To handle the changes on history, you can add a handler to HistoryChanged events, as you can see in the next example:

{{{
	// To put a token on history
	Screen.addToHistory("link1Clicked");
}}}

{{{
	// To add a HistoryChanged Handler
	Screen.addHistoryChangedHandler(new addValueChangeHandler<String>(){
		public void onValueChange(ValueChangeEvent<String> event)
		{
			Window.alert(event.getValue());
		}
	});
}}}

or Declaratively:

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <crux:screen useController="clientHandler" onHistoryChanged='clientHandler.onHistoryChanged' />
   </body>
</html>
}}}

Note that you don't need here to add any IFrame to your host page, as in pure GWT.

=== 3.2.5 Block and Unblock ===

You can block and unblock the user interaction with the page using the static methods {{{Screen.blockToUser()}}} e {{{Screen.unblockToUser()}}}. See the following example:

{{{
  ...
  @Create
   protected TestServiceAsync service;

   public void helloWorld()
   {
        Screen.blockToUser();
        service.hello(new AsyncCallback<String>()
        {
                public void onSuccess(String s) 
                {
                        Screen.unblockToUser();
                        Window.alert(s);
                }
                public void onFailure(Throwable e) 
                {
                        Screen.unblockToUser();
                        Window.alert(e.getMessage());
                }
        });
   }   
   ...
}}} 

== 3.3 Managing Events ==

It's possible to add event handlers:
  # Declaratively.
  # Programmatically.

=== 3.3.1 Add Event Declaratively===
To add an event declaratively, you must create a [UserManual#3.3.3_Controller Controller] and give it a name.

An event declaration must follow the pattern {{{on<eventName> = "<controllerName>.<methodName>"}}}.
For example:

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux" 
      xmlns:gwt="http://www.sysmap.com.br/crux/gwt" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <crux:screen onClose='clientHandler.onClose' useController="clientHandler" >
	       <gwt:textBox id="myBox" />
	       <gwt:button id="myButton" text="Hello" onClick="clientHandler.helloWorld" />
	   </crux:screen>
   </body>
</html>
}}}

Note that you must also "import" your controller through the attribute {{{useController}}} of the screen's tag.

=== 3.3.2 Add Event Programmatically===

You can still use the default GWT mechanism to add handlers for events programmatically, like:

{{{
   ...
   Button myButton = new Button();
   myButton.addClickHandler(new ClickHandler(){
      public void onClick(ClickEvent event)
      {
          Window.alert("hello");
      }
   });
   ...
}}}

The only point to observe here is that you need to put this code in some controller method that is called declaratively, unless you has overwritten the _*Crux*_ EntryPoint and call it directly from there.

=== 3.3.3 Controller===
Controller classes are called to handle events. 

To Create a Controller, you just create a simple java class with the {{{@Controller}}} annotation. That annotation has a value property to inform the name of the controller. That is the name used on pages to point to the controller.

See the following example:

{{{
@Controller("clientHandler")
public class MyController
{
   ... // event handlers here
}
}}}

Your controller can have a lot of methods to handle events. These methods must follow the conditions:
  # It must have public visibility;
  # It must have zero or one argument. If an argument is present, it must be a GwtEvent and this method only will be able to handle this type of events.
  # It must be marked with the annotation {{{@Expose}}}.

See the example:
{{{
@Controller("clientHandler")
public class MyController
{
   @Expose
   public void onClose(CloseEvent<Window> event)
   {
       // code here   
   }
   
   @Expose
   public void helloWorld()
   {
       // code here   
   }
   
   @Expose
   public void onClick(ClickEvent event)
   {
       // code here   
   }
   
   protected void myMethod(String string)
   {
       // code here   
   }
}
}}}

Note that the above controller contains a method that does not follow the conditions to be an event handler ({{{myMethod}}}). It cannot be called declaratively.
 
==== 3.3.3.1 The @Controller Annotation====

The Controller annotation has the following properties:

|| *Property* || *Required* || *Default Value* || *Description* ||
||value||yes|| none ||defines the name of the controller. Used inside pages to point to the controller||
||stateful||no||{{{true}}}||If {{{true}}}, one controller object is created and the same instance is <br>used to handle all events. If {{{false}}}, a new instance is used for each new event||
||autoBind||no||{{{true}}}||If {{{true}}}, [UserManual#3.3.3.4_Value_Binding ValueObjects] are automatically bound from screen widgets before the event <br>occurs and bound back to screen widgets when the event handling terminates ||
||lazy||no|| {{{true}}} ||If {{{true}}}, the controller object is built only when first called.||
||fragment||no|| {{{<empty>}}} ||You can inform a fragment identifier. The compiler will split your code grouping controllers<br> by these identifiers.||

==== 3.3.3.2 The @Create Annotation====

This annotation can be used to simplify the code for Controllers. It automatically creates an object (according with field type) and initializes the field with this value.

This creation is done by a call to GWT.create method, assuring that any generator eventually associated with the requested type will be called correctly.

See the following example:

{{{
@Controller("myNewController")
public class MyClass
{
    public static interface MyScreen extends ScreenWrapper
    {
        Button getMyButton();
        TextBox getMyBox();
    }
	
    @Create
    protected MyScreen myScreen;

    @Create
    protected MyContextWrapper context;

    @Create
    protected TestServiceAsync service;

    @Create
    protected MyControllerCrossDoc crossDoc;

    @Expose
    public void myMethod()
    {
        myScreen.getMyBox().setValue("Test");
        context.setValueTwo(new String[]{"Value One", "Value Two"});
    }
}
}}}

Note that {{{@Create}}} can handle service creation too, despite the fact that the variable type is not the same passed to {{{GWT.create}}} (in above example would be {{{TestService}}}).

The {{{@Create}}} annotation does more than simply creating an object. It also makes some initializations for the created object, depending on the field type (e.g. [UserManual#3.3.3.8_Parameters parameter fields] are loaded, etc.)

You must note, however, that to use {{{@Create}}} on a field, that field must have public or protected visibility or have a public getter and setter methods.

==== 3.3.3.3 The @Expose Annotation====

The Expose annotation has the following properties:

|| *Property* || *Required* || *Default Value* || *Description* ||
||allowMultipleCalls||no|| {{{false}}} ||If {{{true}}}, allow user to dispatch more than one event at time.<br/> If {{{false}}}, when an event handler is called, the screen is blocked <br/>until the method finishes.||


==== 3.3.3.4 Value Binding====

_*Crux*_ provides a mechanism to help you to automatically bind values between screen widgets and data objects.

You can create a value object and annotate it with {{{@ValueObject}}} annotation. Doing it, you allow _*Crux*_ to populate an object of this type with values present on screen widgets before running the event handler methods. After method execution, the screen is also updated with any change in these objects.

See the following example:

{{{
@ValueObject
public class Person
{
	private String name;
	private String phone;
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getPhone() {
		return phone;
	}
	public void setPhone(String phone) {
		this.phone = phone;
	}
}
}}}

{{{
@Controller("myController")
public class MyClass
{
    @Create
    protected Person person;

    @Expose
    public void myMethod()
    {
    	Window.alert(person.getName());
    	person.setPhone("1234-5678");
    }
}
}}}

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux" 
      xmlns:gwt="http://www.sysmap.com.br/crux/gwt">
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <crux:screen useController="myController" >
	       <gwt:textBox id="name" />
	       <gwt:textBox id="phone" />
	       <gwt:button id="myButton" text="Hello" onClick="myController.myMethod" />
	   </crux:screen>
   </body>
</html>
}}}

In the above example, the value of the "name" textBox on page will be bound to field "name" of the Person object created by controller (the same is {{{true}}} to "phone"). After the handler execution, the changes made in the value object will be reflected on page. 

If want, you can use the {{{@ScreenBind}}} annotation on value object field to inform _*Crux*_ which widget will be bound to this field. The above example can be changed to:

{{{
@ValueObject
public class Person
{
	@ScreenBind("person.name")
	private String name;

	@ScreenBind("person.phone")
	private String phone;
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getPhone() {
		return phone;
	}
	public void setPhone(String phone) {
		this.phone = phone;
	}
}
}}}

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux" 
      xmlns:gwt="http://www.sysmap.com.br/crux/gwt" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <crux:screen useController="myController" >
	       <gwt:textBox id="person.name" />
	       <gwt:textBox id="person.phone" />
	       <gwt:button id="myButton" text="Hello" onClick="myController.myMethod" />
	   </crux:screen>
   </body>
</html>
}}}

You can also control which fields of a value object must be bound to some widget screen. {{{@ValueObject}}} annotation has a boolean property called {{{bindWidgetByFieldName}}} (default to {{{true}}}). Setting this value to {{{false}}} make _*Crux*_ to does not bind all value object fields to widgets automatically. If you set this, you must specify for each field, the name of the widget that it will be bound (through {{{@ScreenBind}}} annotation).

See the following example:
{{{
@ValueObject(bindWidgetByFieldName=false)
public class Person
{
	@ScreenBind("person.name")
	private String name;

	@ScreenBind
	private String phone; //will be bound to "phone" widget
	
	private String address; // will not be bound.
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getPhone() {
		return phone;
	}
	public void setPhone(String phone) {
		this.phone = phone;
	}
	public String getAddress() {
		return address;
	}
	public void setAddress(String address) {
		this.address = address;
	}
}
}}}

Any field in a value object can be bound to a widget if it:
  * is a primitive type (or a primitive wrapper);
  * is a CharSequence type (String, StringBuilder, StringBuffer, etc);
  * is a Date type (java.util.Date, java.sql.Date, java.sql.Timestamp, etc);
  * is an Enum type;
  * is any type annotated with {{{@ValueObject}}} annotation;
  * has public or protected visibility or has public getter and setter methods.

The following code shows more examples:

{{{
@ValueObject
public class Person 
{
	private String name;
	private String phone;
	private Date birth;
	private Address address; 
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getPhone() {
		return phone;
	}
	public void setPhone(String phone) {
		this.phone = phone;
	}
	public Date getBirth() {
		return birth;
	}
	public void setBirth(String birth) {
		this.birth = birth;
	}
	public Address getAddress() {
		return address;
	}
	public void setAddress(Address address) {
		this.address = address;
	}
}
}}}

{{{
@ValueObject
public class Address
{
	private String street;
	
	public String getStreet() {
		return street;
	}
	public void setStreet(String street) {
		this.street = street;
	}
}
}}}

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux"
      xmlns:gwt="http://www.sysmap.com.br/crux/gwt" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <crux:screen useController="myController" >
	       <gwt:textBox id="name" />
	       <gwt:dateBox id="birth" />
	       <gwt:textBox id="street" />
	       <gwt:button id="myButton" text="Hello" onClick="myController.myMethod" />
	   </crux:screen>
   </body>
</html>
}}}

In the above example, the field {{{phone}}} will not be bound to any widget, once there is not any widget with id {{{phone}}}. Another important point is that each field only can be bound to widgets that are able to return values of the same type of the field. 

The field {{{birth}}} only can be bound to widgets that implements {{{HasValue<Date>}}} (like {{{DateBox}}}) or {{{HasFormatter}}} and is associated with a formatter that returns {{{Date}}} objects. See the [UserManual#3.7_Formatters Formatters] section to more info about formatters).

If you want to disable the automatic value binding mechanism to a specific controller, you can set the {{{@Controller}}} property {{{autoBind}}} to {{{false}}}. You can, later, control the value object and screen updates through methods {{{Screen.updateScreen(controller)}}} and
{{{Screen.updateController(controller)}}}. See the following example:

{{{
@Controller(value="myController", autoBind=false)
public class MyClass
{
    @Create
    protected Person person;

    @Expose
    public void myMethod()
    {
    	Screen.updateController(this);
    	Window.alert(person.getName());
    	person.setPhone("1234-5678");
    	Screen.updateScreen(this);
    }
}
}}}

==== 3.3.3.5 Using Controllers on Screen====

To inform that a controller will be used on a screen, you must explicitly "import" it using the {{{useController}}} attribute.

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <crux:screen useController="myController, myOtherController" >
	   </crux:screen>
   </body>
</html>
}}}

It is necessary for performance reasons.

However, if you want that a controller be imported in every screen in your application, you can put an annotation {{{@Global}}} in the Controller class.

{{{
@Global
@Controller("myController")
public class MyClass {
       // code here
}
}}}

That will make those controllers be available even if no {{{useController}}} declaration is present on your screen.

==== 3.3.3.6 Communication Between Controllers====

Crux supports communication between different controllers, even if located on different screens (documents).

The first step to implement a cross document communication is creating an interface extending the {{{CrossDocument}}} interface.

{{{
public interface MyControllerCrossDoc extends CrossDocument {
    void myMethod(String str, boolean b, MySerializableDTO dto);
    List<String> myOtherMethod() throws MyCustomException;
}
}}}

The methods declared on this interface are those which you want to make available for calls from other controllers. All method parameters and return types
must be a primitive type (or a primitive wrapper), an Enum or implement {{{java.io.Serializable}}} or {{{com.google.gwt.user.client.rpc.IsSerializable}}}.  

The second step is to make your controller class implement the new interface.

{{{
@Controller("myController")
public class MyController implements MyControllerCrossDoc {
    public void myMethod(String str, boolean b, MySerializableDTO dto){
       // code here
    }
    
    public List<String> myOtherMethod() throws MyCustomException{
       // code here
    }
    
    // You can have any other methods here.
    @Expose
    public void myEventHandlerMethod(ClickEvent event){
       // code here
    }
}
}}}

To ensure that everything will run fine, you must obey the following rules:
  # Both controller class and CrossDocument interface must be coded on the same package;
  # The name of the CrossDocument interface must have the form: {{{"<Controller Name>CrossDoc"}}}.

See the previous code for an example. 

Now we can show how to make the call from a second controller.

{{{
@Controller("mySecondController")
public class MySecondController {
    @Create
    protected MyControllerCrossDoc crossDoc; // you could also use GWT.create(MyControllerCrossDoc.class)

    @Expose
    public void onClick(ClickEvent event){
       
       crossDoc.myMethod("test", true, new MySerializableDTO());
       
       try{
       	  List<String> result = crossDoc.myOtherMethod();
       	  //do something with result...
       }catch(MyCustomException e){
          // handle error
       }
    }
}
}}}

On the previous example, the crossDoc object will call the methods on a controller located on the same screen of the caller object.

If you want to inform a new target for the call, you must cast the crossDoc object to {{{TargetDocument}}} interface and set the target of the call.

{{{
@Controller("mySecondController")
public class MySecondController {
    @Create
    protected MyControllerCrossDoc crossDoc; // you could also use GWT.create(MyControllerCrossDoc.class)

    @Expose
    public void onClick(ClickEvent event){
       ((TargetDocument)crossDoc).setTarget(Target.TOP);       
       crossDoc.myMethod("test", true, new MySerializableDTO());
    }
}
}}}
 
The previous example calls the method on the "myController" controller located on the top window of the current screen.

The following table shows all methods present on {{{TargetDocument}}} interface that can be used to inform the target for the calls.

|| *Method* || *Description* ||
||void setTarget(Target target)||Sets the target for the cross document call. <br/>{{{Target}}} is an Enum described on following list.||
||void setTargetFrame(String frame);||Sets a target frame for the cross document call.||
||void setTargetSiblingFrame(String frame);||Sets a target sibling frame for the cross document call.||
||void setTargetWindow(JSWindow jsWindow);||Sets the target window for the cross document call.<br/>{{{JSWindow}}} is just a {{{JavaScriptObject}}} to wrap the native window object||

The {{{Target}}} Enum supports the following values:

|| *Method* || *Description* ||
||  TOP  ||  Points the CrossDocument object to the [http://www.w3.org/TR/html4/types.html#type-frame-target _top] window  ||
||  PARENT  ||  Points the CrossDocument object to the [http://www.w3.org/TR/html4/types.html#type-frame-target _parent] window  ||
||  SELF  ||  Points the CrossDocument object to the [http://www.w3.org/TR/html4/types.html#type-frame-target _self] (current) window  ||
||  OPENER  ||  Points the CrossDocument object to the window.opener (useful when working with window.open mechanism)  ||
||  ABSOLUTE_TOP  || Points the CrossDocument object to the outermost window of your application, no matter<br/>if executed from inside a frame or other window (e.g. _blank, popup, etc.) ||



Here are some examples:

{{{
  ((TargetDocument)crossDoc).setTarget(Target.OPENER);
  ((TargetDocument)crossDoc).setTarget(Target.TOP);
  ((TargetDocument)crossDoc).setTargetFrame("myInternalNamedFrame");
  ((TargetDocument)crossDoc).setTargetWindow(Popup.getOpener());       
  ((TargetDocument)crossDoc).setTargetWindow(DynaTabs.getTabWindow("secondTab"));
  ((TargetDocument)crossDoc).setTargetWindow(DynaTabs.getSiblingTabWindow("secondTab"));
}}}


==== 3.3.3.7 Validation====

_*Crux*_ supports declaration of validators for a controller handler method. A Validator method is called before the handler method itself. If it runs without problem, the handler is called. If it throws any exception, the handler execution is aborted and a message is reported to the user through the _*Crux*_ [UserManual#3.6_Handling_Errors Error Handlers].

To declare a validator method to a given handler method, you just need to use the {{{@Validate}}} annotation :

{{{
@Controller("clientHandler")
public class MyController
{
   
   @Validate("myValidationMethod")
   @Expose
   public void onClose(CloseEvent<Window> event)
   {
       // code here   
   }
      
   protected void myValidationMethod(CloseEvent<Window> event) throws ValidateException
   {
       // code here   
   }
}
}}}

If no value is passed to the {{{@Validate}}} annotation, _*Crux*_ tries to find a method called {{{validate<methodName>}}}. 

{{{
@Controller("clientHandler")
public class MyController
{
   
   @Validate
   @Expose
   public void onClose(CloseEvent<Window> event)
   {
       // code here   
   }
      
   protected void validateOnClose() throws ValidateException
   {
       // code here   
   }
}
}}}

Note that the validate method can receive a parameter of the same type of the main method parameter type (as in the first example) or no parameter (as in the second example).


==== 3.3.3.8 Parameters Binding====

_*Crux*_ provides you a mechanism to automatically bind values received from the window's URL into data objects. This can be done using the annotations {{{@Parameter}}} and {{{@ParameterObject}}} on controller fields and DTO classes.

You can annotate a controller field with the annotation {{{@Parameter}}} as in the following example:

For the following URL...

{{{
	http://myhost.com/myapp/mymodule/mypage.html?person=Thiago&parameterName=123
}}}

...you may have a Controller like this:

{{{
@Controller("myController")
public class MyClass
{
    @Parameter
    protected String person;

    @Parameter(value="parameterName", required=true)
    protected int field;

    @Expose
    public void myMethod()
    {
    	Window.alert(person);
    	Window.alert(Integer.toString(field));
    }
}
}}}

In the above example, the value of the "person" parameter on window URL will be bound to field "person" of the controller (the same is {{{true}}} to "field"). 

The {{{@Parameter}}} annotation has two fields:
|| *Property* || *Default Value* || *Description* ||
||value|| {{{empty}}} ||defines the name of the parameter. If not present, the field name is used||
||required|| {{{false}}} ||If {{{true}}}, a validation is done to ensure that the parameter is present in the URL.||

If a validation error occurs while binding a parameter, a message is reported to the user through the Crux [UserManual#3.6_Handling_Errors Error Handlers]. A validation error can occur due to type conversion error or by the lack of a required parameter.

Another way to bind parameters is to create an object and annotate it with {{{@ParameterObject}}} annotation, exactly as you do with [UserManual#3.3.3.4_Value_Binding Value Objects]. Doing it, you allow _*Crux*_ to populate an object of this type with values present on window URL parameters. 

See the following example:

{{{
@ParameterObject
public class Parameters
{
	private String person;
	private int field;
	
	public String getPerson() {
		return person;
	}
	public void setPerson(String person) {
		this.person = person;
	}
	public int getField() {
		return field;
	}
	public void setField(int field) {
		this.field = field;
	}
}
}}}

{{{
@Controller("myController")
public class MyClass
{
    @Create
    protected Parameters parameters;

    @Expose
    public void myMethod()
    {
    	Window.alert(parameters.getPerson());
    	Window.alert(Integer.toString(parameters.getField()));
    }
}
}}}


If want, you can use the {{{@Parameter}}} annotation on parameter object field to inform _*Crux*_ which parameter will be bound to this field. The above example can be changed to:

{{{
@ParameterObject
public class Parameters
{
	@Parameter("personName")
	private String person;
	
	@Parameter("fieldParameter", required=true)
	private int field;
	
	public String getPerson() {
		return person;
	}
	public void setPerson(String person) {
		this.person = person;
	}
	public int getField() {
		return field;
	}
	public void setField(int field) {
		this.field = field;
	}
}
}}}

You can also control which fields of a parameter object must be bound to some window parameter. {{{@ParameterObject}}} annotation has a boolean property called {{{bindParameterByFieldName}}} (default to {{{true}}}). Setting this value to {{{false}}} makes _*Crux*_ do not bind all parameters automatically. If you set this, you must specify, for each field, the name of the parameter that will be bound to it (through {{{@Parameter}}} annotation).

See the following example:
{{{
@ParameterObject(bindParameterByFieldName=false)
public class Parameters
{
	@Parameter("personName")
	private String person;
	
	@Parameter("fieldParameter", required=true)
	private int field;
	
	private int field2; // not bound
	
	public String getPerson() {
		return person;
	}
	public void setPerson(String person) {
		this.person = person;
	}
	public int getField() {
		return field;
	}
	public void setField(int field) {
		this.field = field;
	}
	public int getField2() {
		return field2;
	}
	public void setField2(int field2) {
		this.field2 = field2;
	}
}
}}}

Any field in a parameter object can be bound if it:
  * is a primitive type (or a primitive wrapper);
  * is a CharSequence type (String, StringBuilder, StringBuffer, etc);
  * is a Date type (java.util.Date, java.sql.Date, java.sql.Timestamp, etc);
  * is an Enum type;
  * is any type annotated with {{{@ParameterObject}}} annotation;
  * has public or protected visibility or has public getter and setter methods.

== 3.4 I18N ==

_*Crux*_ supports i18n for widgets created declaratively. The native [http://code.google.com/intl/pt-BR/webtoolkit/tutorials/1.6/i18n.html GWT mechanism] is still valid.

You can use the following pattern to tell _*Crux*_ that you want to use a GWT message or a constant value in a widget tag declaration:

{{{
   "${<messageResource>.<messageEntry>}"	
}}}

For example, suppose the following messages interface:

{{{
public interface MyMessages extends Messages
{
	@DefaultMessage("my message")
	String myMessage();
}
}}} 

And the crux page that uses it:

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:gwt="http://www.sysmap.com.br/crux/gwt" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <gwt:label id="label" text="${myMessages.myMessage}" />
   </body>
</html>
}}}

In the above example, the message resource name is derived from interface name. If you want to change this value, you can use the annotation {{{@MessageName}}} in your messages interface.

See the example:

{{{
@Name("msg")
public interface MyConstants extends Constants
{
	@DefaultStringValue("my message")
	String myMessage();
}
}}} 

{{{
   ...
       <bas:label id="label" text="${msg.myMessage}" />
   ...
}}}

== 3.5 Client-Server Communication ==

You can use [http://code.google.com/intl/pt-BR/webtoolkit/tutorials/1.6/RPC.html GWT RPC] and [http://code.google.com/intl/pt-BR/webtoolkit/tutorials/1.6/JSON.html JSON] support to communicate with server. _*Crux*_, however, adds some few features to pure GWT RPC mechanisms to turn this process easier. 

With _*Crux*_, you can use a _Front Controller_ on the server-side. The use of this _Front Controller_ allows you to make just one mapping in your web.xml file.

In other words, you don't need to add a new servlet declaration on your GWT module neither on your web.xml for each new service declared.
 
Other improvement is the use of the  [3.3.3.2_The_@Create_Annotation @Create annotation]. It will create the service object and set its  entry point name to point to the _Front Controller_ automatically. 
 
The following example shows all this features together:
 
{{{
package crux.examples.client.remote;

import com.google.gwt.user.client.rpc.RemoteService;

public interface GreetingService extends RemoteService
{
        public String getHelloMessage(String name);
}
}}}

{{{
public class MyController {
        @Create
        protected GreetingServiceAsync service; 
        
        @Expose
        public void sayHello() {
                service.getHelloMessage("Thiago", new AsyncCallbackAdapter<String>(this){
                                @Override
                                public void onComplete(String result){
                                   Window.alert(result);
                                }
                        }
                );
        }
}
}}}

Note that the service interface does not use the annotation [http://code.google.com/intl/pt-BR/webtoolkit/tutorials/1.6/RPC.html RemoteServiceRelativePath]. It will assume the mapping to the Front Controller. If that annotation was present, _*Crux*_ would use it to set the entry point name.

Another point to observe in the above example is the use of the abstract class {{{AsyncCallbackAdapter}}} in the place of GWT {{{AsyncCallback}}} interface.

That class does the following:
  # Implements a default error handler that will delegate to [UserManual#3.6_Handling_Errors Crux Error Handler] any error received.
  # If controller autoBind for [UserManual#3.3.3.4_Value_Binding ValueObjects] is enabled, it will automatically update screen with value object properties after process the {{{onComplete()}}} method.


So, the two following approach are equivalent:

{{{
@Controller(value="myController", autoBind=true)
public class MyController {
        @Create
        protected GreetingServiceAsync service; 
        
        @Create
        protected Person aValueObject; 

        @Expose
        public void sayHello() {
                service.getHelloMessage("Thiago", new AsyncCallbackAdapter<String>(this){
                                @Override
                                public void onComplete(String result){
                                   aValueObject.setName("Thiago");
                                }
                        }
                );
        }
}
}}}

{{{
@Controller(value="myController", autoBind=false)
public class MyController {
        @Create
        protected GreetingServiceAsync service; 
        
        @Create
        protected Person aValueObject; 

        @Expose
        public void sayHello() {
                Screen.updateController(this);
                service.getHelloMessage("Thiago", new AsyncCallback<String>(this){
                                public void onSuccess(String result){
                                   aValueObject.setName("Thiago");
                                   Screen.updateScreen(this);
                                }
                                public void onFailure(Throwable e){
                                    Crux.getErrorHandler().handleError(e.getLocalizedMessage(), e);
                                    Screen.updateScreen(this);
                                }
                        }
                );
        }
}
}}}

=== 3.5.1 Server Sensitive Methods===

_*Crux*_ supports the [http://www.corej2eepatterns.com/Design/PresoDesign.htm Synchronizer Token] pattern for sensitive methods protection.
This pattern helps to avoid the duplicated request problem and [http://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet CSRF] 
attacks.

To inform _*Crux*_ that a server method is sensitive, you just need to put the annotation {{{@UseSynchronizerToken}}} on the service interface method.

See the following example:

{{{
package crux.examples.client.remote;

public interface GreetingService extends RemoteService
{
   @UseSynchronizerToken
   public String getHelloMessage(String name);
}
}}}   

This annotation accepts the following attributes:

|| *Attribute* || *Type* || *Default* || *Description* ||  
||notifyCallsWhenProcessing||boolean||{{{true}}}||If this property is {{{true}}}, when the user tries to send a duplicated request,<br> an informative message is shown. To change the message, use the property {{{methodIsAlreadyBeingProcessed}}}<br> on ClientMessages.properties file.||
||blocksUserInteraction||boolean||{{{true}}}|| If this property is {{{true}}}, when a request to a sensitive method is fired,<br> the screen became blocked to user, until the method finishes.  ||


== 3.6 Handling Errors==

_*Crux*_ provides two basic interfaces for client errors reporting.
  * {{{ErrorHandler}}}
  * {{{ValidationErrorHandler}}}

Those interfaces are used always occurs an error that needs to be reported to user (or to developer). 
The interface {{{ErrorHandler}}} is called to report errors in application code (bad use of the framework, or an uncaught exception) and {{{ValidationErrorHandler}}} is called to report errors caused by a bad use of the application (typically validations over the screen state, based in business rules, before performing an action).

_*Crux*_ provides a default {{{ErrorHandler}}}  that implements both interfaces and, for the both types of errors:
  * Logs in GWT console all exceptions received.
  * Shows the messages using the {{{Window.alert()}}} method.

If you want to change the default error handling class, you can specify in your module file:

{{{
	<!-- Specify the implementation to ErrorHandler.-->
	<replace-with class="YourErrorHandlerClass">
		<when-type-assignable class="br.com.sysmap.crux.core.client.errors.ErrorHandler" />
	</replace-with>

	<!-- Specify the implementation to ValidationErrorHandler.-->
	<replace-with class="YourValidationErrorHandlerClass">
		<when-type-assignable class="br.com.sysmap.crux.core.client.errors.ValidationErrorHandler" />
	</replace-with>

}}}

== 3.7 Formatters==

Formatters can be used to provide widgets the following capabilities:
  * Input/Output formatting/unformatting;
  * Input masking (masks can be defined with regular expressions);
  * Data conversions to/from string.
  
A widget must implement the interface {{{HasFormatter}}} to be associated with a formatter. Formatters, in turn, can be defined by implementing the interface {{{Formatter}}}.

Here you can see how a formatter could be used:

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:c="http://www.sysmap.com.br/crux"
      xmlns:crux="http://www.sysmap.com.br/crux/widgets" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
      <c:screen useFormatter="phone, date" />
      <crux:maskedTextBox id="maskedTextBox" formatter="phone" width="90"/>   
      <crux:maskedTextBox id="dateMaskedTextBox" formatter="date" width="90"/>   
   </body>
</html>
}}}

The widget {{{MaskedTextBox}}} is delivered with _*Crux*_ default distribution. It is like a GWT TextBox, but provides formatting support.

The following example shows how a custom formatter could be defined:

{{{
@FormatterName("phone")
public class PhoneFormatter implements Formatter
{
	public String format(Object input)
	{
		if (input == null || !(input instanceof String) || ((String)input).length() != 10)
		{
			return "";
		}
		
		String strInput = (String) input;
		
		return "("+strInput.substring(0,2)+")"+strInput.substring(2,6)+"-"+strInput.substring(6);
	}

	public Object unformat(String input) throws InvalidFormatException
	{
		if (input == null || !(input instanceof String) || ((String)input).length() != 13)
		{
			return "";
		}
		String inputStr = (String)input;
		inputStr = inputStr.substring(1,3)+inputStr.substring(4,8)+inputStr.substring(9,13);
		return inputStr;
	}
}
}}} 

The above code, specifies a formatter that will present its associated widget content (a phone number) in the format:{{{ (99)9999-9999}}}. 

The given formatter does not provide input masking feature. To create a version of the formatter with such characteristic, you must implement the interface {{{MaskedFormatter}}}. To create masked formatters for {{{MaskedTextBox}}} widgets, an abstract class that already implements {{{MaskedFormatter}}} can be used. The previous formatter example could be re-written as:

{{{
@FormatterName("phone")
public class PhoneFormatter extends MaskedTextBoxBaseFormatter{
	@Override
	protected String getMask()	{
		return "(99)9999-9999";
	}

	public String format(Object input){
		if (input == null || !(input instanceof String) || ((String)input).length() != 10)	{
			return "";
		}
		
		String strInput = (String) input;
		
		return "("+strInput.substring(0,2)+")"+strInput.substring(2,6)+"-"+strInput.substring(6);
	}

	public Object unformat(String input) throws InvalidFormatException{
		if (input == null || !(input instanceof String) || ((String)input).length() != 13)	{
			return "";
		}
		String inputStr = (String)input;
		inputStr = inputStr.substring(1,3)+inputStr.substring(4,8)+inputStr.substring(9,13);
		return inputStr;
	}
}
}}}

Another example:

{{{
@FormatterName("date")
public static class DateFormatter extends MaskedTextBoxBaseFormatter {

    DateTimeFormat format = DateTimeFormat.getFormat("MM/dd/yyyy");

    protected String getMask(){
        return "99/99/9999";
    }

    public Object unformat(String input){
        if (input == null || input.length() != 10){
            return null;
        }
            
        return format.parse(input);
    }

    public String format(Object input) throws InvalidFormatException {
        if(input == null){
            return "";
        }
        if (!(input instanceof Date)){
            throw new InvalidFormatException();
        }
            
        return format.format((Date) input);
    }
}
}}}


Note that the {{{MaskedFormatter}}} methods ({{{applyMask}}} and {{{removeMask}}}) are already implemented by the abstract class. Only the {{{getMask}}} method must be implemented to specify the pattern used to build the mask.


== 3.8 Data Sources==

DataSources are objects capable of providing a set of data to widgets that implement {{{HasDataSource}}} interface. DataSources support features like pagination, data sorting and editing.

_*Crux*_ provides a wide range of different DataSources that can be classified by the following criteria:

  # How them *present the data*
    # *Paged* - PagedDataSources can divide the data into pages
    # *Scrollable* - This kind of DataSource handles all data in a single page
  # How they *fetch the data* 
    # *Local* - This kind of DataSource can load data once and keep it locally on user's browser, so it can be paged, sorted or edited locally.
    # *Remote* - RemoteDatasources load data on demand, as widgets request them. 

To create a DataSource, you can extend one of the abstract DataSource classes provided by _*Crux*_. The class you should choose depends on which categories (between the exposed above) your DataSource will belong.

For a complete guide about DataSources (including the complete list of basic DataSource classes), consult the following [UsingDataSources tutorial].


== 3.9 Templates ==

Templates in _*Crux*_ are parameterizable XML files that can be used to:
  # Create simple components in a declarative way;
  # Create smart fragments that can be used to compose greater pages;
  # Define reusable layout pages.

A template must be defined in a file with the extension {{{.template.xml}}} and  can be placed anywhere under your classpath (even inside a jar file).Template files must follow the schema {{{http://www.sysmap.com.br/templates}}}.

Sections [UserManual#3.9.1.1_Creating_a_Simple_Component Creating a Simple Component], [UserManual#3.9.1.2_Creating_a_Smart_Fragment Creating a Smart Fragment] and
[UserManual#3.9.1.3_Defining_a_Reusable_Layout Defining a Reusable Layout] shows examples of templates usage.

After creating a template file, you should run the [UserManual#5.1_Schema_Generator Schema Generator] and re-import the {{{crux-catalog.xml}}} file in your Eclipse IDE. This way you will be able to use your templates with the auto-completion feature.

A template can be defined to receive parameters and include sub-sections, as shown in the following examples:  

=== 3.9.1 Examples===

==== 3.9.1.1 Creating a Simple Component====

The file {{{labeledBox.template.xml}}} defines a template for a simple labeled box component:
{{{
<t:template xmlns="http://www.w3.org/1999/xhtml"
	  xmlns:t="http://www.sysmap.com.br/templates" 
	  xmlns:gwt="http://www.sysmap.com.br/crux/gwt" 
	  library="custom">
   
   <gwt:horizontalPanel id="#{id}.hPanel" >
      <gwt:label id="#{id}.label" text="#{label}:" /> 
      <gwt:textBox id="#{id}" value="#{value}" />	  
   </gwt:horizontalPanel>	  
</t:template>
}}}

Then, you can use it on any crux page:
{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:c="http://www.sysmap.com.br/templates/custom" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
      <c:labeledBox id="personName" label="Name" value="Type your name here..." />
   </body>
</html>
}}}

==== 3.9.1.2 Creating a Smart Fragment====

The File {{{userInfo.template.xml}}} defines a simple header, which can show the login and name of the current user. 
It has its own Controller and its own business logic:
{{{
<t:template xmlns="http://www.w3.org/1999/xhtml"
      xmlns:t="http://www.sysmap.com.br/templates" 
      xmlns:gwt="http://www.sysmap.com.br/crux/gwt" 
      library="custom" useController="userController">
   <b:HTMLPanel id="userPanel" onLoadWidget="userController.loadUserInfo" >
      <table>
   	     <tr>
   	        <td>Login:</td>
   	        <td><gwt:label id="login" /></td>
   	     </tr>
   	     <tr>
   	        <td>Name:</td>
   	        <td><gwt:label id="name" /></td>
   	     </tr>
      </table>
   </b:HTMLPanel>
</t:template>
}}}

You can use it on any page you want, without any additional configuration:
{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:gwt="http://www.sysmap.com.br/crux/gwt" 
      xmlns:c="http://www.sysmap.com.br/templates/custom" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
      <c:userInfo />
      ...
   </body>
</html>
}}}

==== 3.9.1.3 Defining a Reusable Layout====
The file {{{pageLayout.template.xml}}} defines a common layout that has a menu located on the left and a place to insert the page body:
{{{
<t:template xmlns="http://www.w3.org/1999/xhtml"
      xmlns:t="http://www.sysmap.com.br/templates" 
      xmlns:crux="http://www.sysmap.com.br/crux/widgets"
      xmlns:gwt="http://www.sysmap.com.br/crux/gwt" 
      xmlns:c="http://www.sysmap.com.br/templates/custom" 
	  library="custom">

   <gwt:dockPanel id="centeringPanel" width="100%" height="100%">
      <gwt:cell direction="north" height="70" verticalAlignment="top">
          <c:userInfo />
      </gwt:cell>
      <gwt:cell direction="south">
         <gwt:dockPanel id="menuTabsDividerPannel">
            <gwt:cell direction="west">
               <crux:stackMenu id="menu" onLoadWidget="#{onLoadMenu}" ></crux:stackMenu>
            </gwt:cell>
            <gwt:cell direction="east">
               <t:section name="body" />
            </gwt:cell>
         </gwt:dockPanel>
      </gwt:cell>
   </gwt:dockPanel>
</t:template>
}}}

Then, you can use it on any crux page:
{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux" 
      xmlns:gwt="http://www.sysmap.com.br/crux/gwt" 
      xmlns:c="http://www.sysmap.com.br/templates/custom" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
      <crux:screen useController="myController" />
      <c:pageLayout onLoadMenu="myController.loadMenuItems">
         <c:body>
            <!-- Body comes here -->
            <gwt:label id="test" text="Hello World!!" />
         </c:body>
      </c:pageLayout>
   </body>
</html>
}}}

Note that the above template reuses another template (userInfo) defined in previous section. 

=== 3.9.2 Templates attributes and children ===

According with template.xsd file, the tag {{{<template>}}} declare the following attributes:

|| *Attribute* || *Description* ||
||library||Required attribute that inform the library into which this template will be included.<br> This will define the name of the xsd file where the template<br> definition will be put and the namespace associated with this file.<br> ({{{http://www.sysmap.com.br/templates/<library>}}})||
||useController||Adds controllers to screen controller list||  
||useSerializable||Adds serializables to screen serializable list||  
||useFormatter||Adds formatters to screen formatter list||  
||useDataSource||Adds DataSources to screen data sources list||  

As shown in the previous examples, you can create a template that receive attributes and children. 
  * To define an attribute for your template, just write the attribute in the form {{{#{attributeName}}}} wherever you want to apply the attribute value.
  * To define a child tag for your template, use the tag {{{section}}}. It will create a placeholder in your template, which will be replaced by the content of the child tag declared on the page that uses the template. (See the example shown on section [UserManual#3.9.1.3_Defining_a_Reusable_Layout Defining a Reusable Layout]).

== 3.10 Running With a Different Server ==

To run your _*Crux*_ application under DevMode with a different server, you must follow all the steps described at the GWT [http://code.google.com/intl/pt-BR/webtoolkit/doc/latest/FAQ_DebuggingAndCompiling.html documentation]. 

In addition to these steps, you must add the following JVM argument to your application server: {{{-DCrux.dev=true}}}.

Note that this parameter just needs to be inserted when running the server with development purposes. In production, you don't need any additional configuration. 


= 4 Coding Server Side =

== 4.1 Writing Server-Side Code ==

As we said in section [UserManual#3.5_Client-Server_Communication Client-Server Communication], _*Crux*_ supports the [http://code.google.com/intl/pt-BR/webtoolkit/tutorials/1.6/RPC.html GWT RPC] mechanism with some few features to turn it easier.

At server-side, the main difference between GWT and _*Crux*_ is that your service implementation class does not need to extend {{{RemoteServiceServlet}}}. It is nothing more than a POJO and 
just needs to implement the business interface.

{{{
public interface GreetingService extends RemoteService{
	public String getHelloMessage(String name);
}
}}}

{{{
public class GreetingServiceImpl implements GreetingService{
   public String getHelloMessage(String name){
      return "Server says: Hello, " + name + "!'";
   }
}
}}}

To find out which implementation will be used for a given service interface, _*Crux*_ will search for classes that implements that interface and use the first one found.

This behavior  can be changed, as shown in section [UserManual#4.3.2.5_serviceFactory serviceFactory].

If your service class needs to access the HttpServletRequest, HttpServletResponse or HttpSession objects, it can implement one or more of the following interfaces:
  * {{{RequestAware}}}  - makes your Service able to access the [http://download.oracle.com/javaee/5/api/javax/servlet/http/HttpServletRequest.html HttpServletRequest] object;
  * {{{ResponseAware}}} - makes your Service able to access the [http://download.oracle.com/javaee/5/api/javax/servlet/http/HttpServletResponse.html HttpServletResponse] object;
  * {{{SessionAware}}}  - makes your Service able to access the [http://download.oracle.com/javaee/5/api/javax/servlet/http/HttpSession.html HttpSession] object.

{{{
public class GreetingServiceImpl implements GreetingService, RequestAware, ResponseAware{
   private HttpServletRequest request;
   private HttpServletResponse response;
   	
   public void setRequest(HttpServletRequest request){
      this.request = request;
   }
   public void setResponse(HttpServletResponse response){
      this.response = response;
   }
   ...   
}
}}}

== 4.2 I18n ==

_*Crux*_ provides a mechanism to use i18n in your server-side classes. It's very similar to the GWT i18n for client-side.

You can create interfaces and use the annotation {{{@br.com.sysmap.crux.core.i18n.DefaultServerMessage}}} exactly as you do at client-side.

The main differences are:
  * Your interfaces don't need to extend any other interface;
  * You must use the factory method {{{MessagesFactory.getMessages(<interfaceClass>)}}} instead of {{{GWT.create()}}} to create an instance of your interface.

See the following example:
{{{
public interface ServerMessages 
{
	@DefaultServerMessage("My server message: {0}.")
	String myServerMessage(String message);
}
}}} 

{{{
public MyServerClass
{
   private static ServerMessages messages = MessagesFactory.getMessages(ServerMessages.class);
   
   public void method()
   {
      System.out.println(messages.myServerMessage("test"));
   }
}
}}}

You can create a resource file called {{{ServerMessages}}} and put it under your application classpath to change messages for a specific locale. Example:

{{{
(file: ServerMessages_pt_BR.properties)
myServerMessage=Minha mensagem no servidor: {0}.
}}}

The mechanism exposed above will work properly for all your classes that are called by a service. _*Crux*_ will resolve locale problems in its [UserManual#3.5_Client-Server_Communication FrontController], before delegating the application control to your service implementation. 

However, if you plan to access i18n messages in classes called by a filter (that executes before the _*Crux* FrontController_ Servlet), you need to configure a filter in your web.xml file. Read the section [UserManual#4.3.1_Web.xml Web.xml] to see how to do this.

== 4.3 Setup ==

To use _*Crux*_ in your application, you will need the following files:

  * In production time, inside the {{{WEB-INF/lib}}} folder:
    * commons-logging.jar
    * crux-core.jar
    * gwt-servlet.jar
    * crux-scannotation.jar
    * javassist.jar
  * In development time:
   	* in addition to the previous files, inside the {{{WEB-INF/lib}}} folder:
      * crux-widgets.jar
      * crux-gwt-widgets.jar
      * saxon9.jar
      * saxon9-dom.jar
    * in any folder, since it is visible for the GWT Hosted Mode Console and for ANT tasks:
      * crux-compiler.jar
      * gwt-dev.jar 
      * gwt-ll.dll (platform dependent)
      * gwt-module.dtd
      * gwt-user.jar

Using the [UserManual#2.1_Install Project Generator] you will get a ready to use project structure. 

=== 4.3.1 Web.xml ===
To setup the _*Crux* Front Controller_, shown in [3.5_Client-Server_Communication previous section], you must add the following lines to your web.xml file:

{{{
	<servlet>
		<servlet-name>remoteServiceServlet</servlet-name>
		<servlet-class>
			br.com.sysmap.crux.core.server.dispatch.RemoteServiceServlet
		</servlet-class>
	</servlet>

	<servlet-mapping>
		<servlet-name>remoteServiceServlet</servlet-name>
		<url-pattern>*.rpc</url-pattern>
	</servlet-mapping>
}}}

There are some other configurations you will need to do to run your application in development environment: 

{{{
	<filter>
		<display-name>CruxFilter</display-name>
		<filter-name>CruxFilter</filter-name>
		<filter-class>br.com.sysmap.crux.core.server.CruxFilter</filter-class>
	</filter>
	<filter-mapping>
		<filter-name>CruxFilter</filter-name>
		<url-pattern>*.html</url-pattern>
	</filter-mapping>
}}}

The above lines is needed by _*Crux*_ [http://code.google.com/intl/pt-BR/webtoolkit/doc/1.6/DevGuideCodingBasics.html#DevGuideDeferredBinding Generators] to find out which module is being compiled. This is used for better performance (see [FAQ#Performance this] for more information). Because that information is used only for compilation, it just needs to be present in development environment.

In development time, you will need to have this too:
{{{
	<filter>
		<display-name>DeclarativeUIFilter</display-name>
		<filter-name>DeclarativeUIFilter</filter-name>
		<filter-class>br.com.sysmap.crux.core.declarativeui.filter.DeclarativeUIFilter</filter-class>
		<init-param>
			<param-name>outputCharset</param-name>
			<param-value>ISO-8859-1</param-value>
		</init-param>
	</filter>
	<filter-mapping>
		<filter-name>DeclarativeUIFilter</filter-name>
		<url-pattern>*.html</url-pattern>
	</filter-mapping>
}}}   

This filter is used to transform your _.crux.xml_ files in pure _html_ files. This process is only done in development. In a production environment, your application can access the generated version of the page directly. 

The two above filters, does nothing (its right... nothing!) if used in a production environment. Still, they are removed by an Ant task generated to deploy your project (if you are using the [UserManual#2.1_Install _*Crux* Project Generator_]).

You can add an optional listener called InitializerListener to initialize some _*Crux*_ resources to turn the first call to application faster.

{{{
   <listener>
      <listener-class>br.com.sysmap.crux.core.server.InitializerListener</listener-class>
   </listener>
}}}

If you need i18n before the _*Crux* FrontController_ Servlet, you have to put these lines too:

{{{
	<filter>
		<display-name>I18NFilter</display-name>
		<filter-name>I18NFilter</filter-name>
		<filter-class>br.com.sysmap.crux.core.i18n.I18NFilter</filter-class>
	</filter>
	<filter-mapping>
		<filter-name>I18NFilter</filter-name>
		<url-pattern>*.rpc</url-pattern>
	</filter-mapping>
}}}

=== 4.3.2 Crux.properties ===

_*Crux*_ provides some configuration options that can modify behaviors on the framework.

Those options can be informed through:
  # A command line argument to JVM, adding a System property like: {{{-DCrux.<propertyName>=<propertyValue>}}}. {{{e.g.: -DCrux.wrapSiblingWidgets=false}}}.
  # A file called {{{Crux.properties}}} that can be put (optionally) in any place under your classpath.

If you use both ways shown, the command line has precedence. 

The following properties can be set:

|| *Property* || *Description* || *Default Value* ||
||wrapSiblingWidgets||If {{{false}}}, widgets created declaratively under the same parent<br> has no guarantee of order||{{{true}}}||
||localeResolver||Class used by _*Crux*_ to resolve locale for user at the server side||br.com.sysmap.crux.core.i18n.LocaleResolverImpl||
||screenResourceResolver||Class used by _*Crux*_ to retrieve the screen page files||br.com.sysmap.crux.core.rebind.screen.ScreenResourceResolverImpl||
||classPathResolver||Class used by _*Crux*_ to resolve classpath files||br.com.sysmap.crux.core.server.classpath.ClassPathResolverImpl||
||serviceFactory||Class used by _*Crux*_ to instantiate controller classes||br.com.sysmap.crux.core.server.dispatch.ServiceFactoryImpl||
||allowAutoBindWithNonDeclarativeWidgets||Allow AutoBind feature to be used with widgets that were not created by the declarative engine|||{{{true}}}||
||enableChildrenWindowsDebug||If {{{true}}}, propagates the GWT debug parameters to <br>other windows opened while application runs under the DevMode||{{{true}}}||
||enableWebRootScannerCache||If {{{true}}}, uses a cache for the resources scanner||{{{true}}}||
||enableHotDeploymentForWebDirs||If {{{true}}}, _*Crux*_ enables hot deployment for all resources on web dir, including templates||{{{true}}}||
||enableHotDeploymentForWidgetFactories||If {{{true}}}, *Crux*_ supports hot deployment when new widgets types are used on screens.||{{{true}}}||


==== 4.3.2.1 wrapSiblingWidgets ====

To achieve very significant improvements on screen creation performance, _*Crux*_ needs that each widget in your page is the unique child of its parent HTML element.

The property {{{wrapSiblingWidgets}}} will automatically create an empty {{{<span>}}} tag around each widget that does not follow this restriction. 

See the following example:

{{{
   ...
   <body>
       <crux:textBox id="box1" />
       <crux:textBox id="box2" />
       <div>
	       <crux:textBox id="box3" />
       </div>
   </body>
   ...
}}}

That will be transformed into the following DOM elements:

{{{
   ...
   <body>
       <span><input type="text" id="box1" ... /></span>
       <span><input type="text" id="box2" ... /></span>
       <div>
	       <input type="text" id="box3" ... />
       </div>
   </body>
   ...
}}}

If you want, you can disable this mechanism setting this property to {{{false}}}. In such a case, you will need to care about placing each widget inside a panel, or inside its own html tag. Otherwise, _*Crux*_ will not guarantee the order of the sibling widgets.

If this property is disabled, the previous example can result in the following sequence of elements into the DOM:
{{{
   ...
   <body>
       <input type="text" id="box2" ... />
       <div>
	       <input type="text" id="box3" ... />
       </div>
       <input type="text" id="box1" ... />
   </body>
   ...
}}}

In that case, the best would be refactoring the code to:
{{{
   ...
   <body>
       <crux:flowPanel id="panel1">   
          <crux:textBox id="box1" />
          <crux:textBox id="box2" />
          <div>
	         <crux:textBox id="box3" />
          </div>
       </crux:flowPanel>   
   </body>
   ...
}}}

==== 4.3.2.2 localeResolver ====

By default, _*Crux*_ will use the same mechanism used by [http://code.google.com/intl/pt-BR/webtoolkit/doc/1.6/DevGuideI18nAndA11y.html#DevGuideSpecifyingLocale GWT at client side] to resolve the user locale.

It means that you can, for example, pass the locale through an URL parameter, like:
{{{
http://www.example.org/myapp.html?locale=pt_BR
}}}

However, if you need to change this behavior , you can specify your own LocaleResolver class through the property {{{localeResolver}}}. That implementation can adopt a custom rule to identify the user's locale.

Your class just needs to implement the following interface:

{{{
public interface LocaleResolver 
{
	void initializeUserLocale(HttpServletRequest request);
	Locale getUserLocale() throws LocaleResolverException;
}
}}}

==== 4.3.2.3 screenResourceResolver ====

The property {{{screenResourceResolver}}} tells _*Crux*_ which class will be used to retrieve an InputStream related to a given a page of your application. 
It can be useful to create new plugins which may need to do some processing on pages before they are consumed by the framework.

Your class just needs to implement the following interface:

{{{
public interface ScreenResourceResolver
{
	InputStream getScreenResource(String screenId) throws InterfaceConfigException;
	Set<String> getAllScreenIDs(String module) throws ScreenConfigException;
}
}}}

==== 4.3.2.4 classPathResolver ====

_*Crux*_ depends on knowing some paths in your application in order to retrieve the HTML pages, scan for Controllers and other operations. The interface
{{{ClassPathResolver}}} is used for this purpose. 

There are two default ClassPathResolvers delivered with _*Crux*_. The one you need depends on what [UserManual#6_Project_Layouts project layout] your application uses.
|| *Project Layout* || *ClassPathResolver* || *Why?* ||
|| Standalone Application || ClassPathResolverImpl || It's the simplest and the fastest one. ||
|| Module Application || ModuleClassPathResolver || It can find any Crux resource (like pages, templates, etc.) even if they are packaged in jar files.<br>Its necessary because a module can inherit on other modules and those dependencies must be packaged as jar files and placed under the {{{WEB-INF/lib}}} folder. ||
|| Module Container Application || ModuleClassPathResolver || Exactly the same reason of the previous layout. ||

 

==== 4.3.2.5 serviceFactory ====

The section [UserManual#4.1_Writing_Server-Side_Code Writing Server-Side Code] shows the default mechanism used to discovery your service implementation classes.

However, you can need to change this to, for example, integrate _*Crux*_ with some other server framework like [http://www.springsource.org spring], [http://code.google.com/p/google-guice/ guice] or to make your service classes EJBs.

Using the property {{{serviceFactory}}} you can specify your own factory class, which just needs to implement the following interface:

{{{
public interface ServiceFactory 
{
	Object getService(String serviceName);
	void initialize(ServletContext context);
}
}}}

==== 4.3.2.6 allowAutoBindWithNonDeclarativeWidgets====

This property tells to _*Crux*_ that it must support the AutoBind feature even if the widget that is  bound with a specific field is created and added to Screen programmatically. To prevent undesirable  bugs on applications, the default value to this is {{{true}}}. 

However, if you don't need this feature, you can disable it to have some performance improvement. If this property is set to {{{false}}}, _*Crux*_ can transfer to a generator the responsibility of handling the binding code, keeping the final code smaller and simpler.

==== 4.3.2.7 enableChildrenWindowsDebug====

GWT 2.0 uses a parameter on the browser URL to inform the GWT Plugin that it must enable the debugger. If  {{{enableChildrenWindowsDebug}}} parameter is set to {{{true}}}, _*Crux*_ will propagate the GWT debug parameter to other windows, for example, when you invoke {{{Popup.open}}}.

==== 4.3.2.8 enableWebRootScannerCache====

_*Crux*_ uses a resource scanner to find the application pages, templates and other things. The process of scanning the entire application is not a fast task. 
For this reason, _*Crux*_ uses an internal cache to avoid the duplicated processing of some resources, enhancing the performance of the scanner. By the way, 
if need, you can disable that cache, setting {{{enableWebRootScannerCache}}} to {{{false}}}. 

==== 4.3.2.9 enableHotDeploymentForWebDirs====

Enabling this options costs a little bit more in performance terms, but can turn easier the development, once you will not need to restart your server to see changes on templates.

==== 4.3.2.10 enableHotDeploymentForWidgetFactories====

_*Crux*_ only register on its client engine the WidgetFactories that are already used to parse your page(s). If you set this option to {{{true}}}, _*Crux*_ will register all possible factories. It will turn possible hot deployments that insert new kinds of widgets on your page.

This behavior will be adopted only if you are under development mode ({{{-DCrux.dev=true}}}). When you compile your source for distribution (to deploy in production environment), you must run the compiler in production mode ({{{-DCrux.dev=false}}} or absent). This will make _*Crux*_ ignore the {{{enableHotDeploymentForWidgetFactories}}} option and optimize the generated code. 


= 5 Crux Tools =

== 5.1 Schema Generator==

The {{{Schema Generator}}} Tool searches in the project classpath for _*Crux*_ widget libraries and generates a XSD file for each of them. It also generates a XSD file for each [UserManual#3.9_Templates template] file found.

You can invoke SchemaGenerator in two different ways:
  # calling it with the command line:
      {{{java br.com.sysmap.crux.tools.schema.SchemaGenerator <projectBaseDir> <outputDir>}}}
  # calling the ant task {{{<generate-schemas>}}}, that is already defined on the project {{{build.xml}}} file, generated by the [UserManual#2.1_Install Project Generator]

SchemaGenerator also produces an eclipse catalog file containing all generated XSD files.

== 5.2 Crux Compiler==

The {{{CruxCompiler}}} tool compiles a crux project. It converts all {{{.crux.xml}}} files to simple {{{.html}}} files and then call the GWT compiler to produce the javascript for all your application modules.

You can invoke CruxCompiler in two different ways:
  # calling it with the command line:
      {{{java br.com.sysmap.crux.tools.compile.CruxCompiler <outputDir>}}}
  # calling the ant task {{{<compile-scripts>}}}, that is already defined on the project {{{build.xml}}} file, generated by the [UserManual#2.1_Install Project Generator]


= 6 Project Layouts =

A _*Crux*_ application can be built for different purposes. There are some distinct layouts of projects provided by Crux 
that you can use for achieve these purposes. Which layout you should choose for your application depends on its characteristics. 
The currently supported layouts are: 

  * Standalone Application
  * Module Application
  * Module Container Application 

Below, we talk about each one:


== 6.1 Standalone Application ==

This layout is a template for an ordinary Java web project. It has facilities for help you with tasks of 
building and deploying the final application. It is the default and simplest layout of project, ideal for 
small web applications, coded by small teams, for which the volume of source-code and the parallelization 
of coding tasks are not so hard to administer. 


== 6.2 Module Application ==

GWT supports modularization, allowing you to divide your application and package its parts separately. This 
is especially useful for building large applications. _*Crux*_ extends such mechanism adding some other features 
to turn the modular development easier. 

The Module Application layout is designed to model fragments, reusable or not, of a large application. A module 
project can be coded, tested, versioned and even delivered totally separated of the rest of the application. This 
can provide a drastic improvement in the development speed, in the cost of maintenance and, we believe, in the 
quality of the final product. 

Every application of this flavor must be packaged a jar file, named with the following pattern {{{<moduleName>.module.jar}}}. 
This way, it will be ready to be used by another module or by a [UserManual#6.3_Module_Container_Application Module Container Application]. 
A packaged module can contain pre-compiled resources for improving the compiling speed of the dependent applications. 


== 6.3 Module Container Application ==

This can be considered the ideal layout for corporative applications, which are typically built by a larger 
number of developers and consist of many dozens of use cases, some of which tend to be reused by multiple 
functionalities. 

This kind of application can contain multiple [UserManual#6.2_Module_Application Module Applications] that 
just need to be available in its classpath. More specifically, modules must be placed inside the {{{WEB-INF/lib}}} 
folder. 

