#labels Featured,Phase-Requirements
= History =

_*Crux*_ is a component framework created over [http://code.google.com/p/google-web-toolkit/ GWT] for fast development of web applications.

It is derived from a masters degree dissertation that was defended in 2008 at the Federal University of Minas Gerais (UFMG) - Minas Gerais, Brazil -  and can be read [http://www.dcc.ufmg.br/pos/cursos/defesas/980M.PDF here] (available only in portuguese).

_*Crux*_ is now maintained by [http://www.sysmap.com.br Sysmap Solutions] as an open source project.

= What can *_Crux_* do? =
_*Crux*_ allows you to create web user interfaces in a declarative and modularized way, what drastically improves development speed and code maintainability. In other words, it brings you the best of both worlds: the comfort of creating pages with HTML and the elegance of controlling those pages using Java code.

The entire set of widgets from GWT is available for using in _*Crux*_, and it is easy to create or even plug in an already existent set of widgets. See more about custom widgets at [CreatingCustomWidgets Creating Custom Widgets] section.


=Simple Example=

The following example assumes that you are familiar with [http://code.google.com/p/google-web-toolkit/ GWT]. If this is not the case, please consult its documentation first for better understand this example.

_*Crux*_ provides a declarative way for component creation. It uses _`<span>`_ tags to inform that a component must be created at the specific location on the page. Look at the following code:

{{{
<html>
   <head>
       <script language='javascript' src='cruxtest/cruxtest.nocache.js'></script>
   </head>
   <body>
       <span id='myButton' _type='button' _value='Hello' _onclick='clientHandler.helloWorld' />
   </body>
</html>
}}}

This code is a GWT host page for a hypothetical example module called _CruxTest_ .

You can see that a _`<span>`_ tag is used to inform that a component of type _'button'_ must be rendered at the body of html page. That button contains a click event pointing to _'clientHandler.helloWorld'_. It means that a method called _'helloWorld'_ from a class identified by the alias _'clientHandler'_ will be called to handle this event calls.

You can see at the following code block how we tell _*Crux*_ which  class must be associated with the alias _'clientHandler'_:

{{{
package br.com.sysmap.test.client;

import com.google.gwt.user.client.Window;

@ClientController("clientHandler")
public class Teste
{
   public void helloWorld()
   {
      Window.alert("Hello World!!");
   }
}
}}}

And now you can see the code for the _CruxTest_ module declaration:
{{{
<module rename-to='cruxtest'>
   <inherits name='br.com.sysmap.crux.core.Crux'/>
   <inherits name='br.com.sysmap.crux.basic.CruxBasicComponents'/>
</module>
}}}


=Example with server interaction=

This example ilustrate how you can interact with server using _*Crux*_. Consider the same HTML page and module definition from the previous example and the following controller class:

{{{
package br.com.sysmap.test.client;

import br.com.sysmap.teste.client.service.TesteServiceAsync;
import br.com.sysmap.crux.core.client.controller.Create;
import br.com.sysmap.crux.core.client.rpc.AsyncCallbackAdapter;

import com.google.gwt.user.client.Window;

@ClientController("clientHandler")
public class Teste
{
   @Create
   protected TesteServiceAsync service;

   public void helloWorld()
   {
	service.hello(new AsyncCallbackAdapter<String>()
	{
		@Override
		public void onSuccess(String s) 
		{
			Window.alert(s);
		}
		
	});
   }   
}
}}}

The following block of code shows the server class called by above example:

{{{
package br.com.sysmap.teste.server.control;

import br.com.sysmap.teste.client.service.TestService;

public class TestController implements TesteService
{
   public String hello()
   {
        return "hello!";
   }
}
}}}

Where the interface TestService is defined as:
{{{
package br.com.sysmap.teste.client.service;

import com.google.gwt.user.client.rpc.RemoteService;

public interface TesteService extends RemoteService 
{
    public String hello();
}
}}}

And the async interface for the service is:

{{{
package br.com.sysmap.teste.client.service;

import com.google.gwt.user.client.rpc.AsyncCallback;

public interface TesteServiceAsync 
{
	void hello(AsyncCallback<String> callback);
}
}}}

As you can observe, it is pretty similiar to pure GWT way to communicate. In fact you can also use that way if you want. The main differences in _*Crux's*_ approach is:
  # You don't need to add a new servlet declaration on GWT module definition nether on web.xml for each new service declared.
  # Your service implementation class does not need to extend the GWT RemoteServiceServlet. It just need to implements the service interface.
  # You don't need to inform through _ServiceDefTarget.setServiceEntryPoint_ the path for your service nether use the RemoteServiceRelativePath annotation on your service interface. _*Crux*_ provides a FrontController. 
  # You can use the annotation _Create_ rather than _GWT.create_. it can be used not only for services, but for any field of the controller class.

=_*Crux*_ Tools=

Default _*Crux*_ distribution provides a set of tools to support the development. The most important one is an extension that allows pages to be created as XML files.

Using crux XML files you can benefit from auto-completitions and XInclude support for breaking your pages in reuseable blocks.

If XML support is enabled, the previous example can be written as following:

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:crux="http://www.sysmap.com.br/crux/ui/1.0" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <crux:button value="Hello" onClick="clientHandler.helloWorld" />
   </body>
</html>
}}}

The XML pages are used only for development porpouses. They are translated to HTML (with _`<span>`_ tags) and accessed as static resources in production environment. It can be done by an ant task (also included in default distribution). 

During development, a filter intercept the requests to _*Crux*_ pages and process a transformation before writes the response. It ensures that the page recept by the browser is the same in production and in development scenarios. In a production scenario, the filter does nothing. 