#labels Featured,Phase-Requirements
= What is *_Crux_*? =
_*Crux*_ is a component framework created over [http://code.google.com/p/google-web-toolkit/ GWT] for fast development of web applications. 

It is derived from a masters degree dissertation defended in 2008 at the Federal University of Minas Gerais (UFMG) - Minas Gerais, Brazil - which can be read [http://www.dcc.ufmg.br/pos/cursos/defesas/980M.PDF here] (available only in Portuguese).

_*Crux*_ is now maintained by [http://www.sysmap.com.br Sysmap Solutions] as an open source project.

The following documentation assumes that you are familiar with [http://code.google.com/p/google-web-toolkit/ GWT]. If this is not the case, please consult its documentation first. 

= What can *_Crux_* do? =
_*Crux*_ allows you to create web user interfaces in a declarative and modularized way, which drastically improves development speed and code maintainability. In other words, it brings you the best of both worlds: the comfort of creating pages with HTML and the elegance of controlling those pages using Java code.

All GWT widgets are available for using with _*Crux*_, and it is easy to create new widgets or even plug in an already existent set of them. Fore more information about custom widgets, take a look at [WidgetDeveloperManual Creating Custom Widgets].

=Simple Example=
The following example illustrates how to create a simple HTML page with _*Crux*_ and how to interact with it using a java controller.

*The page:*
{{{
<html 
	xmlns="http://www.w3.org/1999/xhtml" 
	xmlns:crux="http://www.sysmap.com.br/crux/ui/1.0">
	<head>
		<title>My Page</title>
	</head>
	<body>
		<script type="text/javascript" src="cruxexample.nocache.js"></script>
		<crux:screen useController="myController"/>
		<table border="1">
			<tr>
				<td>
					<crux:textBox id="nameTextBox"/>
				</td>
				<td>
					<crux:button id="helloButton" onClick="myController.sayHello" text="Say Hello!" />
				</td>
			</tr>
			<tr>
				<td colspan="2">
					<crux:label id="greetingLabel"/>			
				</td>	
			</tr>
		</table>
	</body>
</html>
}}}

*The controller:*
{{{
package crux.examples.client.controller;

import br.com.sysmap.crux.core.client.screen.Screen;
import br.com.sysmap.crux.core.client.controller.Controller;
import com.google.gwt.user.client.ui.Label;
import com.google.gwt.user.client.ui.TextBox;

@Controller(value="myController")
public class MyController {

	@Expose
	public void sayHello() {

		TextBox textBox = Screen.get("nameTextBox", TextBox.class);
		String name = textBox.getValue();
		
		Label label = Screen.get("greetingLabel", Label.class);
		label.setText("Hello, " + name + "!");
	}	
}
}}}


*The result:*

http://crux-framework.googlecode.com/svn/wiki/images/say_hello_before.jpg

http://crux-framework.googlecode.com/svn/wiki/images/say_hello_after.jpg

Using the annotation {{{@Controller}}}, the class {{{MyController}}} is exposed to the page, under the alias {{{myController}}}. Then, it is ready to be used as an event handler for the button {{{helloButton}}} or for any other widget in the page. The {{{helloButton}}} contains a click event pointing to {{{myController.sayHello}}}. This means that a method called {{{sayHello}}}, exposed by the annotation {{{@Expose}}}, will be invoked on the controller {{{myController}}} to handle click events from {{{helloButton}}}.

It's important to say that tags {{{<crux:button/>}}} and {{{<crux:label/>}}}, used on the HTML example above, are not part of the *_Crux_* core. Actually, they come from a *_Crux_* plug-in, called [http://code.google.com/p/crux-framework-tools/ CruxHtmlTags]. In other words, *_Crux_* can also be used with plain HTML pages. For more information about how to use plain HTML pages, take a look at *[UserManual#3.1_Building_User_Interface Building User Interface]*

=Example with server interaction=

This example illustrates how you can interact with server using _*Crux*_. Consider the same HTML page from the previous example. The controller class was modified to access the remote server and now looks like this:
{{{
package crux.examples.client.controller;

import br.com.sysmap.crux.core.client.screen.Screen;
import br.com.sysmap.crux.core.client.controller.Controller;
import br.com.sysmap.crux.core.client.controller.Create;
import br.com.sysmap.crux.core.client.rpc.AsyncCallbackAdapter;
import com.google.gwt.user.client.ui.Label;
import com.google.gwt.user.client.ui.TextBox;
import crux.examples.client.remote.GreetingServiceAsync;

@Controller(value="myController")
public class MyController {
	
	@Create
	protected GreetingServiceAsync service; 
	
	@Expose
	public void sayHello() {
		
		TextBox textBox = Screen.get("nameTextBox", TextBox.class);
		final String name = textBox.getValue();
		
		service.getHelloMessage(name, new AsyncCallbackAdapter<String>(this){

				@Override
				public void onComplete(String result){
					Label label = Screen.get("greetingLabel", Label.class);
					label.setText(result);		
				}
			}
		);
	}
}
}}}

The {{{GreetingServiceAsync }}} interface, which resides on client side, is given below:

{{{
package crux.examples.client.remote;

import com.google.gwt.user.client.rpc.AsyncCallback;

public interface GreetingServiceAsync
{
	public void getHelloMessage(String name, AsyncCallback<String> callback);
}
}}}

It has a sibling synchronous interface, shared by server and client sides:

{{{
package crux.examples.client.remote;

import com.google.gwt.user.client.rpc.RemoteService;

public interface GreetingService extends RemoteService
{
	public String getHelloMessage(String name);
}
}}}

And, finally, the server-side business class (implementing the last given interface):

{{{
package crux.examples.server;

import crux.examples.client.remote.GreetingService;

public class GreetingServiceImpl implements GreetingService
{
	public String getHelloMessage(String name)
	{
		return "Server says: Hello, " + name + "!'";
	}
}
}}}

As you can observe, it is pretty similar to pure GWT way to communicate. In fact you can also use that way if you want. The main differences in _*Crux's*_ approach is:
  # You don't need to add a new servlet declaration on GWT module definition nether on web.xml for each new service declared.
  # Your service implementation class does not need to extend the GWT {{{RemoteServiceServlet}}}. It just need to implements the service interface.
  # You don't need to inform through {{{ServiceDefTarget.setServiceEntryPoint}}} the path for your service nether use the {{{RemoteServiceRelativePath}}} annotation on your service interface. _*Crux*_ provides a _front controller_ for handling that. 
  # You can use the annotation {{{@Create}}} rather than {{{GWT.create}}} method. It can be used not only for services, but for any field of the controller class.