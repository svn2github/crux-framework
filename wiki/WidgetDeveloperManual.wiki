= 1 Introduction =

If you are not familiar with _*Crux*_ framework, please consult the [UserManual User Manual] first.

This documentation will show you how to work with custom widgets inside _*Crux*_. 

== 1.1 GWT widgets ==

_*Crux*_ widgets are  [http://code.google.com/intl/pt-BR/webtoolkit/doc/latest/DevGuideUiWidgets.html GWT widgets]. _*Crux*_ just offer an aditional engine where those widgets can be plugged.

So, you can plug any custom widgets in _*Crux*_ Declarative Engine. If you are not familiar with GWT widgets development, please consult its documentation  [http://code.google.com/intl/pt-BR/webtoolkit/doc/latest/DevGuideUiWidgets.html first].

= 2 _Crux_ Declarative Engine = 

== 2.1 Overview == 

_*Crux*_ declarative engine uses factories to create the widgets based on informations contained inside the html pages. For a deeper explanation about how this declarative engine works, consult the following  [WidgetDeveloperManual#2.2_How_Engine_Works section].

To register a custom widget in _*Crux*_ declarative engine, you just have to create a factory class for it.

See the following example:

{{{
@DeclarativeFactory(id="myWidget", library="myLibrary")
public class MyWidgetFactory extends WidgetFactory<MyWidget>
{
   @Override
   public MyWidget instantiateWidget(Element element, String widgetId) 
   {
      return new MyWidget();
   }
	
   @Override
   @TagAttributes({
      @TagAttribute("myWidgetAttribute"),
   })
   public void processAttributes(WidgetFactoryContext<MyWidget> context) throws InterfaceConfigException {}
}
}}}

Note that the above class uses the annotation {{{@DeclarativeFactory}}} and extends the abstract class {{{WidgetFactory}}}. These two conditions are necessary for any _*Crux*_ widget factory.

Through the {{{@DeclarativeFactory}}} annotation, you can specify the name of the library where your widget will be registered and the name that will be associated with your widget itself. 

Before we go deeper inside the code showed and see more examples, let's see how you could use the widget registered with _*Crux*_ declarative engine:

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:mylib="http://www.sysmap.com.br/crux/myLibrary" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <mylib:myWidget id="myWidgetID" myWidgetAttribute="attributeValue"/>
   </body>
</html>
}}} 


Note that a namespace called {{{http://www.sysmap.com.br/crux/myLibrary}}} is used on the above page. A {{{XSD}}} file defining this namespace is created by the [UserManual#5.1_Schema_Generator SchemaGenerator].

The example showed assumes that the widget {{{MyWidget}}} contains a public String property called {{{myWidgetAttribute}}} that will be bounded to the tag attribute {{{myWidgetAttribute}}} on {{{crux.xml}}} file.


== 2.2 How Engine Works ==

If you look to the source code of any _*Crux*_ page on your browser, you will find a lot of {{{<span>}}} tags similar to the following one:

{{{
<span id="myWidgetID" _type="myLibrary_myWidget" _myWidgetAttribute="attributeValue"></span>
}}}
 
This HTML page with those tags is generated by the [UserManual#5.3_Crux_Compiler Crux Compiler]. 

 
The _*Crux*_ EntryPoint will start a factory class called {{{ScreenFactory}}}, that will search for all {{{<span>}}} tags with the attribute {{{_type}}} on the page document. Those tags represent your widgets declarations on the {{{.crux.xml}}} file.


{{{ScreenFactory}}} uses the attribute {{{_type}}} to decide which factory class it wil call to create the desired widget, for each of those {{{<span>}}} tags found. Then, {{{ScreenFactory}}} replaces the {{{<span >}}} tag by the widget created. 

Of course, we could use another kind of metadata structure on HTML pages, like javascript arrays, or some kind of strings (like XML) on a javascript block to serve as insume to the _*Crux*_ {{{ScreenFactory}}}. However, some widgets on a page contains other HTML blocks as children. Sometimes, those HTML blocks contains other child widgets... So, the most natural way to handle this is to use the own HTML DOM as the source of the metadata. It turn the implementation very easy and the page load much faster.


For aditional information about this declarative approach, consult the _*Crux*_ [FAQ FAQ].


== 2.3 WidgetFactory ==

{{{WidgetFactory}}} is the basic class for any _*Crux*_ widget factory. {{{ScreenFactory}}} delegates to those factories the creation of the requested widget, based ont the {{{<span>}}} element on the DOM.

{{{WidgetFactory.createWidget()}}} method is called for this creation. It executes the following steps:

  # Calls the method {{{T instantiateWidget(element, widgetId)}}}
  # Calls the method {{{void processAttributes(WidgetFactoryContext<T> context)}}}
  # Calls the method {{{void processEvents(WidgetFactoryContext<T> context)}}}
  # Calls the method {{{void processChildren(WidgetFactoryContext<T> context)}}}
  # Calls the method {{{void postProcess(WidgetFactoryContext<T> context)}}}
  # Return the created widget to {{{ScreenFactory}}}, that will properly attach it on screen and replaces its {{{<span>}}} metadata tag.
  
The  {{{instantiateWidget}}} method is abstract and must be implemented by any Factory subclass. The other methods can be used to factory to specify and to process the informations about widget attributes, events and children. The next sections describe how  to properly overwrite each of those methods to serve your widget needs.


=== 2.3.1 The instantiateWidget method===


The {{{instantiateWidget}}} method is called to the widget object instantiation. The {{{<span>}}} element is passed as parameter and can be used if the widget to be created needs some attribute in its constructor.If the widget showed on [WidgetDeveloperManual#2.1_Overview section 2.1] needs some attribute, we could write something like:

{{{
@DeclarativeFactory(id="myWidget", library="myLibrary")
public class MyWidgetFactory extends WidgetFactory<MyWidget>
{
   @Override
   public MyWidget instantiateWidget(Element element, String widgetId) 
   {
      return new MyWidget(element.getAttribute("_theRequiredAttribute"));
   }
  ...
}
}}}

The purpose of this method is just instantiate the widget. The best place to handle the extraction of attributes, events and children is not here. You must use the other methods showed bellow.

=== 2.3.2 The processAttributes method===

This method has to goals:
  # Turn easier the binding beetwen the widget metadata element (the {{{<span>}}} tag) and the widget itself.
  # Inform to _*Crux*_ engine whiche attributes this factory can handle. This information is used to generate a proper XSD file, that can be used to enable autocompletion for developers (See  [UserManual#5.1_Schema_Generator SchemaGenerator]). 




=== 2.3.3 The processEvents  method===


=== 2.3.4 The processChildren  method===


=== 2.3.5 The postProcess  method===


