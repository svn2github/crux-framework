= 1 Introduction =

If you are not familiar with _*Crux*_ framework, please consult the [UserManual User Manual] first.

This documentation will show you how to work with custom widgets inside _*Crux*_. 

== 1.1 GWT widgets ==

_*Crux*_ widgets are  [http://code.google.com/intl/pt-BR/webtoolkit/doc/latest/DevGuideUiWidgets.html GWT widgets]. _*Crux*_ just offer an additional engine where those widgets can be plugged.

So, you can plug any custom widgets in _*Crux*_ Declarative Engine. If you are not familiar with GWT widgets development, please consult its documentation  [http://code.google.com/intl/pt-BR/webtoolkit/doc/latest/DevGuideUiWidgets.html first].

= 2 _Crux_ Declarative Engine = 

== 2.1 Overview == 

_*Crux*_ declarative engine uses generators to create the widgets based on informations contained on the {{{.crux.xml}}} pages. 

To register a custom widget in _*Crux*_ declarative engine, you just have to create a factory class for it.

See the following example:

{{{
@DeclarativeFactory(id="myWidget", library="myLibrary", targetWidget=MyWidget.class)
@TagAttributes({
   @TagAttribute("myWidgetAttribute")
})
public class MyWidgetCreator extends WidgetCreator<WidgetCreatorContext>
{
   @Override
   public WidgetCreatorContext instantiateContext()
   {
      return new WidgetCreatorContext();
   }
}
}}}

Note that the above class uses the annotation {{{@DeclarativeFactory}}} and extends the abstract class {{{WidgetCreator}}}. These two conditions are necessary for any _*Crux*_ widget factory.

Through the {{{@DeclarativeFactory}}} annotation, you can specify the name of the library where your widget will be registered and the name that will be associated with your widget itself. 

Before we go deeper inside the code shown and see more examples, let's see how you could use the widget registered with _*Crux*_ declarative engine:

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:mylib="http://www.cruxframework.org/crux/myLibrary" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <mylib:myWidget id="myWidgetID" myWidgetAttribute="attributeValue"/>
   </body>
</html>
}}} 


Note that a namespace called {{{http://www.cruxframework.org/crux/myLibrary}}} is used on the above page. A {{{XSD}}} file defining this namespace is created by the [UserManual#5.1_Schema_Generator SchemaGenerator].

The example shown assumes that the widget {{{MyWidget}}} contains a public String property called {{{myWidgetAttribute}}} that will be bound to the tag's attribute {{{myWidgetAttribute}}} on {{{crux.xml}}} file.


== 2.2 WidgetCreator ==

{{{WidgetCreator}}} is the basic class for any _*Crux*_ widget factory. {{{ScreenFactory}}} delegates to those factories the generation of the code responsible for the creation of the requested widget, based on the widget element on the {{{.crux.xml}}} page's DOM.

{{{WidgetCreator}}} subclasses can use some annotations to describe the attributes, events and children that the widget accepts. These annotations are used for two purposes:
  # Automatically bind the information declared into the {{{.crux.xml}}} pages with the widgets created by the _*Crux*_ engine.
  # Inform to _*Crux*_ engine which attributes this factory can handle. This information is used to generate a proper XSD file, that can be used to enable autocompletion for developers (See  [UserManual#5.1_Schema_Generator SchemaGenerator]).

{{{WidgetCreator.createWidget()}}} method is called for the widget creation. It processes the attributes, events and children declared through the factory annotations and then executes the following steps:

  # Calls the method {{{void instantiateWidget(SourcePrinter out, C context)}}}
  # Calls the method {{{void processAttributes(SourcePrinter out, C context)}}}
  # Calls the method {{{void processEvents(SourcePrinter out, C context)}}}
  # Calls the method {{{void processChildren(SourcePrinter out, C context)}}}
  # Calls the method {{{void postProcess(SourcePrinter out, C context)}}}
  
These methods can be used by the factory to specify and process the information about widget's attributes, events and children. All of those methods receive a parameter of type {{{WidgetCreatorContext}}}. This class has the following public methods:

|| *Method* || *Description* ||
|| getWidget || Returns the name of the variable containing the widget to be created  ||
|| getWidgetElement || Returns the widget metadata element (a JSONObject) ||
|| getWidgetId || Returns the widget identifier ||
|| readWidgetProperty(String propertyName) || Read the property value from the widget metadata ||
|| readChildProperty(String key) || Read the property value from the metadata of the current widget child been processed ||

The WidgetCreator's methods can be overridden when you want to add some specific behavior.


=== 2.2.1 The WidgetCreator Annotations===

_*Crux*_ provides annotations to help the processing of attributes, events and children.

To process attributes, you can use the annotations {{{@TagAttributes}}} and {{{@TagAttribute}}}, like on the following example:

{{{
@DeclarativeFactory(id="myWidget", library="myLibrary", targetWidget=MyWidget.class)
@TagAttributes({
   @TagAttribute("myAttribute"),
   @TagAttribute(value="theRequiredAttribute", required=true),
   @TagAttribute(value="intAttribute", type=Integer.class)
})
public class MyWidgetCreator extends WidgetCreator<WidgetCreatorContext>{
   @Override
   public WidgetCreatorContext instantiateContext()
   {
      return new WidgetCreatorContext();
   }
}
}}}




















=== 2.2.2 The instantiateWidget method===


The {{{instantiateWidget}}} method is called to generate the code for instantiate a new widget object. If the widget shown on [WidgetDeveloperManual#2.1_Overview section 2.1] needs some attribute to be instantiated, we could write something like:

{{{
@DeclarativeFactory(id="myWidget", library="myLibrary", targetWidget=MyWidget.class)
public class MyWidgetCreator extends WidgetCreator<WidgetCreatorContext>{
   @Override
   public void instantiateWidget(SourcePrinter out, WidgetCreatorContext context) 
                                throws CruxGeneratorException{
      String className = getWidgetClassName();
		
      String theRequiredAttribute = context.readWidgetProperty("theRequiredAttribute");
      out.println("final "+className + " " + context.getWidget()+" = new "+
                   className+"("+EscapeUtils.quote(theRequiredAttribute)+");");
   }
   ...
}
}}}

The purpose of this method is just instantiate the widget. The best place to handle the extraction of attributes, events and children is not here. You must use the other methods, shown bellow, in order to take advantage of all benefits this engine offers you.

=== 2.2.2 Attributes and Events Processing===

The {{{processAttributes}}} and {{{processEvents}}} methods are used to process attributes and events that can not be handled automatically (only declared with the factory annotations).  


==== 2.2.2.1 The processAttributes method====

This method has two goals:
  # Turn easier the binding beetwen the widget metadata element (the {{{<span>}}} tag) and the widget itself.
  # Inform to _*Crux*_ engine which attributes this factory can handle. This information is used to generate a proper XSD file, that can be used to enable autocompletion for developers (See  [UserManual#5.1_Schema_Generator SchemaGenerator]).
  

See the following code:
   
{{{
@DeclarativeFactory(id="myWidget", library="myLibrary")
public class MyWidgetCreator extends WidgetCreator<MyWidget>
{

   @Override
   @TagAttributesDeclaration({
      @TagAttributeDeclaration("myWidgetAttribute")
   })
   public void processAttributes(WidgetCreatorContext<MyWidget> context) throws InterfaceConfigException 
   {
      super.processAttributes(context);
      
      MyWidget widget = context.getWidget();
      String attr = element.getAttribute("_myWidgetAttribute");
      if (StringUtils.isNotEmpty(attr))
      {
         widget.setMyWidgetAttribute(attr);
      }
   }
}
}}}

The first thing done by the above processAttributes method is call {{{super.processAttributes}}}. It is important, once all attributes common to all GWT widgets (like {{{visible, width, height}}} and others) are handled by {{{WidgetCreator.processAttributes}}}. 

Other important point to observe is the annotation {{{@TagAttributesDeclaration}}} on method. It is used to inform all attributes supported by this widget. This information is used by  [UserManual#5.1_Schema_Generator SchemaGenerator]. Note that {{{WidgetCreator.processAttributes}}} has this same annotation including more attributes.   [UserManual#5.1_Schema_Generator SchemaGenerator] will consider attributes declared on super classes to generate the XSD files.


If you observe the code shown on section [WidgetDeveloperManual#2.1_Overview 2.1], you will note that the annotation {{{@TagAttributes}}} is used in the place of {{{@TagAttributesDeclaration}}}. The two annotations are very similar and support the same attributes. However, when you use the {{{@TagAttributes}}}, _*Crux*_ will generate the code for the binding of those attributes. The code on section 2.1 just declare the attribute {{{myWidgetAttribute}}} on the method annotation and does not need to implement all the code shown in this section.

In other words, the above code can bre written as:

{{{
@DeclarativeFactory(id="myWidget", library="myLibrary")
public class MyWidgetCreator extends WidgetCreator<MyWidget>
{
   @Override
   @TagAttributes({
      @TagAttribute("myWidgetAttribute")
   })
   public void processAttributes(WidgetCreatorContext<MyWidget> context) throws InterfaceConfigException 
   {
      super.processAttributes(context);
   }
}
}}}

The annotation {{{@TagAttributesDeclaration}}} must be used when you want to inform _*Crux*_ that the attributes exist (because the [UserManual#5.1_Schema_Generator SchemaGenerator]), but you need to parse it programmatically. The code below shows a situation where you can face this need: the widget has an attribute that is required by its constructor. Note that you can use both annotations on a {{{processAttributes}}} method:

{{{
@DeclarativeFactory(id="myWidget", library="myLibrary")
public class MyWidgetCreator extends WidgetCreator<MyWidget>
{
   @Override
   public MyWidget instantiateWidget(Element element, String widgetId) 
   {
      return new MyWidget(element.getAttribute("_theRequiredAttribute"));
   }
   
   @Override
   @TagAttributes({
      @TagAttribute("myWidgetAttribute")
   })
   @TagAttributesDeclaration({
      @TagAttributeDeclaration(value="theRequiredAttribute", required=true)
   })
   public void processAttributes(WidgetCreatorContext<MyWidget> context) throws InterfaceConfigException 
   {
      super.processAttributes(context);
   }
}
}}}

===== 2.3.2.1.1 @TagAttributes Annotation=====

The {{{@TagAttributes}}} has one attribute (value) of type array of {{{@TagAttribute}}}. Each {{{@TagAttribute}}} is used to inform one attribute of the widget.

{{{@TagAttribute}}} accepts the following attributes:

|| *Name* || *Type* || *Required* || *Default* || *Description* ||
|| value || String || yes || - || The name of the attribute. ||
|| defaultValue || String || no || "" || The default value to be used on XSD. ||
|| type || Class<?> || no || String || The type of the attribute. ||
|| required || boolean || no || false || Inform if the attribute is required. ||
|| supportsI18N || boolean || no || false || Inform if the attribute support _*Crux*_ declarative i18n. ||

The supported types for an attribute is:
  * any primitive type or primitive wrapper;
  * String;
  * Date;
  * any enum type.
 
All enum types will be mapped to simpleTypes on the generated XSD. 

The parser generated by _*Crux*_ will handle all type conversions needed and all declarative i18n messages.

The same properties exist on {{{@TagAttributesDeclaration}}} annotation. However, using it, the parsing of the {{{<span>}}} element and the binding of the attributes is not done automatically.


==== 2.3.2.2 The processEvents  method====

This method does almost the same as processAttributes, however, it handles widget events.

Two annotations can be used on {{{processEvents}}} method: {{{@TagEvents}}} and {{{@TagEventsDeclaration}}}.

We can compare these annotations with {{{@TagAttributes}}} and  {{{@TagAttributesDeclaration}}} .

See the following example:

{{{
@DeclarativeFactory(id="myWidget", library="myLibrary")
public class MyWidgetCreator extends WidgetCreator<MyWidget>
{
   @Override
   @TagEvents({
      @TagEvent(ClickEvtBind.class)
   })	
   @TagEventsDeclaration({
      @TagEventDeclaration("onCustomEvent")
   })
   public void processEvents(WidgetCreatorContext<MyWidget> context) throws InterfaceConfigException 
   {
      super.processEvents(context);
      
      final Event eventCustom = EvtBind.getWidgetEvent(context.getElement(), "onCustomEvent");
      if (eventCustom != null)
      {
         context.getWidget().addCustomEventHandler(new CustomEventHandler()
         {
            public void onCustomEvent(CustomEvent event)
            {
               Events.callEvent(eventCustom, event);
            }
         });
      }
   }
}
}}}

===== 2.3.2.2.1 @TagEvents Annotation=====


The {{{@TagEvents}}} has one attribute (value) of type array of {{{@TagEvent}}}. Each {{{@TagEvent}}} is used to inform one event of the widget.

{{{@TagEvent}}} accepts one attribute of type {{{EvtBinder}}}. {{{EvtBinders}}} are classes that can automatically bind event declarations to widgets.

_*Crux*_ offers {{{EvtBinders}}} for all GWT events and for  custom _*Crux*_ widgets events. The following table shows the GWT {{{EvtBinders}}}:

|| *Event type* || *Class* || *Widget type* ||
|| onBeforeSelection || BeforeSelectionEvtBind || HasBeforeSelectionHandlers<?> ||
|| onBlur || BlurEvtBind || HasBlurHandlers ||
|| onChange || ChangeEvtBind || HasChangeHandlers ||
|| onClick || ClickEvtBind || HasClickHandlers ||
|| onFocus || FocusEvtBind || HasFocusHandlers ||
|| onHighlight || HighlightEvtBind || HasHighlightHandlers<?> ||
|| onKeyDown || KeyDownEvtBind || HasKeyDownHandlers ||
|| onKeyPress || KeyPressEvtBind || HasKeyPressHandlers ||
|| onKeyUp|| KeyUpEvtBind || HasKeyUpHandlers ||
|| onError || LoadErrorEvtBind || HasErrorHandlers ||
|| onLoad || LoadEvtBind || HasLoadHandlers ||
|| onMouseDown || MouseDownEvtBind || HasMouseDownHandlers ||
|| onMouseMove || MouseMoveEvtBind || HasMouseMoveHandlers ||
|| onMouseOut || MouseOutEvtBind || HasMouseOutHandlers ||
|| onMouseOver || MouseOverEvtBind || HasMouseOverHandlers ||
|| onMouseUp || MouseUpEvtBind || HasMouseUpHandlers ||
|| onMouseWheel || MouseWheelEvtBind || HasMouseWheelHandlers ||
|| onOpen || OpenEvtBind || HasOpenHandlers<?> ||
|| onScroll || ScrollEvtBind || HasScrollHandlers ||
|| onSelection || SelectionEvtBind || HasSelectionHandlers<?> ||
|| onShowRange || ShowRangeEvtBind || HasShowRangeHandlers<?> ||
|| onChange || ValueChangeEvtBind || HasValueChangeHandlers<?> ||


The annotation {{{@TagEventDeclaration}}} has one attribute of type {{{String}}}. This attribute only informs to _*Crux*_ the name of the event. The parsing of the {{{<span>}}} element and the binding with the widget must be done programmatically, as shown on the previous example.

==== 2.3.2.3 Factories Inheritance====

The annotations present on {{{processAttributes}}} and {{{processEvents}}} methods of Widget factories super classes and implemented  interfaces are also considered by _*Crux*_ engine. 

Let's take a look at the following example. 

{{{
public interface HasNameFactory<T extends HasName>
{
   @TagAttributes({
      @TagAttribute("name")
   })	
   void processAttributes(WidgetCreatorContext<T> context) throws InterfaceConfigException;
}
}}}  

{{{
@DeclarativeFactory(id="myWidget", library="myLibrary")
public class MyWidgetCreator extends WidgetCreator<MyWidget> implements HasNameFactory<MyWidget>
{
	...
   @Override
   @TagAttributes({
      @TagAttribute("myWidgetAttribute")
   })
   public void processAttributes(WidgetCreatorContext<MyWidget> context) throws InterfaceConfigException 
   {
      super.processAttributes(context);
   }
}
}}}

That factory shown above will accept and automatically bind the attributes {{{myWidgetAttribute}}} and {{{name}}} to {{{MyWidget}}}.

_*Crux*_ libraries use the inheritance support to turn easy the development of its factories. GWTWidgets library has interfaces that binds attributes and events for most of GWT basic interfaces for widgets. Just implementing some of those interfaces is enough to provide your factory with the ability of binding various attributes and events. The current existing interfaces are:

|| *Interface* || *Attributes* || *Events* || 
|| HasAllFocusHandlersFactory || - || onFocus, onBlur ||
|| HasAllKeyHandlersFactory || - || onKeyUp, onKeyPress, onKeyDown ||
|| HasAllMouseHandlersFactory || - || omMouseUp, onMouseDown, onMouseOver, onMouseOut, onMouseMove, onMouseWheel ||
|| HasAnimationFactory || animationEnabled || - ||
|| HasBeforeSelectionHandlersFactory || - || onBeforeSelection ||
|| HasChangeHandlersFactory || - || onChange ||
|| HasClickHandlersFactory || - || onClick ||
|| HasCloseHandlersFactory || - || onClose ||
|| HasDirectionFactory || direction || - ||
|| HasHighlightHandlersFactory || - || onHighlight ||
|| HasNameFactory || name || - ||
|| HasOpenHandlersFactory || - || onOpen ||
|| HasScrollHandlersFactory || - || onScroll ||
|| HasSelectionHandlersFactory || - || onSelection ||
|| HasShowRangeHandlersFactory || - || onShowRange ||
|| HasTextFactory || text || - ||
|| HasValueChangeHandlersFactory || - || onChange ||
|| HasWordWrapFactory || wordWrap || - ||

=== 2.3.3 Children Processing===

==== 2.3.3.1 The processChildren  method====

==== 2.3.3.2 WidgetChildProcessor====

=== 2.3.4 The postProcess  method===