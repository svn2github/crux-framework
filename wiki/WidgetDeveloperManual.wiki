= 1 Introduction =

If you are not familiar with _*Crux*_ framework using, please consult the [UserManual User Manual] first.

This documentation will show you how to work with custom widgets inside _*Crux*_. 

== 1.1 GWT widgets ==

_*Crux*_ widgets are  [http://code.google.com/intl/pt-BR/webtoolkit/doc/latest/DevGuideUiWidgets.html GWT widgets]. _*Crux*_ just offer an aditional engine where those widgets can be plugged.

So, you can plug any custom widgets in _*Crux*_ Declarative Engine. If you are not familiar with GWT widgets development, please consult its documentation  [http://code.google.com/intl/pt-BR/webtoolkit/doc/latest/DevGuideUiWidgets.html first].

= 2 _Crux_ Declarative Engine = 

== 2.1 Overview == 

_*Crux*_ declarative engine uses factories to create the widgets based on informations contained inside the html pages. For a deeper explanation about how this declarative engine works, consult the following  [WidgetDeveloperManual#2.2_How_Engine_Works sectionl].

To register a custom widget in _*Crux*_ declarative engine, you just have to create a factory class for it.

See the following example:

{{{
@DeclarativeFactory(id="myWidget", library="myLibrary")
public class MyWidgetFactory extends WidgetFactory<MyWidget>
{
   @Override
   public MyWidget instantiateWidget(Element element, String widgetId) 
   {
      return new MyWidget();
   }
	
   @Override
   @TagAttributes({
      @TagAttribute("myWidgetAttribute"),
   })
   public void processAttributes(WidgetFactoryContext<MyWidget> context) throws InterfaceConfigException {}
}
}}}

Note that the above class uses the annotation {{{@DeclarativeFactory}}} and extends the abstract class {{{WidgetFactory}}}. These two conditions are necessary for any _*Crux*_ widget factory.

Through the {{{@DeclarativeFactory}}} annotation, you can specify the name of the library where your widget will be registered and the name that will be associated with your widget itself. 

Before we go deeper inside the code showed and see more examples, let's see how you could use the widget registered with _*Crux*_ declarative engine:

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:mylib="http://www.sysmap.com.br/crux/myLibrary" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <mylib:myWidget id="myWidgetID" myWidgetAttribute="attributeValue"/>
   </body>
</html>
}}} 


Note that a namespace called {{{http://www.sysmap.com.br/crux/myLibrary}}} is used on the above page. A {{{XSD}}} file defining this namespace is created by the [UserManual#5.1_Schema_Generator SchemaGenerator].

The example showed assumes that the widget {{{MyWidget}}} contains a public String property called {{{myWidgetAttribute}}} that will be bounded to the tag attribute {{{myWidgetAttribute}}} on {{{crux.xml}}} file.


== 2.2 How Engine Works ==

If you look to the source code of any _*Crux*_ page on your browser, you will find a lot of {{{<span>}}} tags similar to the following one:

{{{
<span id="myWidgetID" _type="myLibrary_myWidget" _myWidgetAttribute="attributeValue"></span>
}}}
 
This HTML page with those tags is generated by the [UserManual#5.3_Crux_Compiler Crux Compiler]. 

 
The _*Crux*_ EntryPoint will start a factory class called {{{ScreenFactory}}}, that will search for all {{{<span>}}} tags with the attribute {{{_type}}} on the page document. Those tags represent your widgets declarations on the {{{.crux.xml}}} file.


{{{ScreenFactory}}} uses the attribute {{{_type}}} to decide which factory class it wil call to create the desired widget, for each of those {{{<span>}}} tags found.


== 2.3 WidgetFactory ==

{{{WidgetFactory}}} is the basic class for any _*Crux*_ widget factory. ...
