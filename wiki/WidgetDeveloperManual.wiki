= 1 Introduction =

If you are not familiar with _*Crux*_ framework, please consult the [UserManual User Manual] first.

This documentation will show you how to work with custom widgets inside _*Crux*_. 

== 1.1 GWT widgets ==

_*Crux*_ widgets are  [http://code.google.com/intl/pt-BR/webtoolkit/doc/latest/DevGuideUiWidgets.html GWT widgets]. _*Crux*_ just offer an aditional engine where those widgets can be plugged.

So, you can plug any custom widgets in _*Crux*_ Declarative Engine. If you are not familiar with GWT widgets development, please consult its documentation  [http://code.google.com/intl/pt-BR/webtoolkit/doc/latest/DevGuideUiWidgets.html first].

= 2 _Crux_ Declarative Engine = 

== 2.1 Overview == 

_*Crux*_ declarative engine uses factories to create the widgets based on informations contained inside the html pages. For a deeper explanation about how this declarative engine works, consult the following  [WidgetDeveloperManual#2.2_How_Engine_Works section].

To register a custom widget in _*Crux*_ declarative engine, you just have to create a factory class for it.

See the following example:

{{{
@DeclarativeFactory(id="myWidget", library="myLibrary")
public class MyWidgetFactory extends WidgetFactory<MyWidget>
{
   @Override
   public MyWidget instantiateWidget(Element element, String widgetId) 
   {
      return new MyWidget();
   }
	
   @Override
   @TagAttributes({
      @TagAttribute("myWidgetAttribute")
   })
   public void processAttributes(WidgetFactoryContext<MyWidget> context) throws InterfaceConfigException 
   {
      super.processAttributes(context);
   }
}
}}}

Note that the above class uses the annotation {{{@DeclarativeFactory}}} and extends the abstract class {{{WidgetFactory}}}. These two conditions are necessary for any _*Crux*_ widget factory.

Through the {{{@DeclarativeFactory}}} annotation, you can specify the name of the library where your widget will be registered and the name that will be associated with your widget itself. 

Before we go deeper inside the code showed and see more examples, let's see how you could use the widget registered with _*Crux*_ declarative engine:

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:mylib="http://www.sysmap.com.br/crux/myLibrary" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <mylib:myWidget id="myWidgetID" myWidgetAttribute="attributeValue"/>
   </body>
</html>
}}} 


Note that a namespace called {{{http://www.sysmap.com.br/crux/myLibrary}}} is used on the above page. A {{{XSD}}} file defining this namespace is created by the [UserManual#5.1_Schema_Generator SchemaGenerator].

The example showed assumes that the widget {{{MyWidget}}} contains a public String property called {{{myWidgetAttribute}}} that will be bounded to the tag attribute {{{myWidgetAttribute}}} on {{{crux.xml}}} file.


== 2.2 How Engine Works ==

If you look to the source code of any _*Crux*_ page on your browser, you will find a lot of {{{<span>}}} tags similar to the following one:

{{{
<span id="myWidgetID" _type="myLibrary_myWidget" _myWidgetAttribute="attributeValue"></span>
}}}
 
This HTML page with those tags is generated by the [UserManual#5.3_Crux_Compiler Crux Compiler]. 

 
The _*Crux*_ EntryPoint will start a factory class called {{{ScreenFactory}}}, that will search for all {{{<span>}}} tags with the attribute {{{_type}}} on the page document. Those tags represent your widgets declarations on the {{{.crux.xml}}} file.


{{{ScreenFactory}}} uses the attribute {{{_type}}} to decide which factory class it wil call to create the desired widget, for each of those {{{<span>}}} tags found. Then, {{{ScreenFactory}}} replaces the {{{<span >}}} tag by the widget created. 

Of course, we could use another kind of metadata structure on HTML pages, like javascript arrays, or some kind of strings (like XML) on a javascript block to serve as insume to the _*Crux*_ {{{ScreenFactory}}}. However, some widgets on a page contains other HTML blocks as children. Sometimes, those HTML blocks contains other child widgets... So, the most natural way to handle this is to use the own HTML DOM as the source of the metadata. It turn the implementation very easy and the page load much faster.


For aditional information about this declarative approach, consult the _*Crux*_ [FAQ FAQ].


== 2.3 WidgetFactory ==

{{{WidgetFactory}}} is the basic class for any _*Crux*_ widget factory. {{{ScreenFactory}}} delegates to those factories the creation of the requested widget, based ont the {{{<span>}}} element on the DOM.

{{{WidgetFactory.createWidget()}}} method is called for this creation. It executes the following steps:

  # Calls the method {{{T instantiateWidget(element, widgetId)}}}
  # Calls the method {{{void processAttributes(WidgetFactoryContext<T> context)}}}
  # Calls the method {{{void processEvents(WidgetFactoryContext<T> context)}}}
  # Calls the method {{{void processChildren(WidgetFactoryContext<T> context)}}}
  # Calls the method {{{void postProcess(WidgetFactoryContext<T> context)}}}
  # Return the created widget to {{{ScreenFactory}}}, that will properly attach it on screen and replaces its {{{<span>}}} metadata tag.
  
The  {{{instantiateWidget}}} method is abstract and must be implemented by any Factory subclass. The other methods can be used to factory to specify and to process the informations about widget attributes, events and children.  All of those other methods receive  a parameter of type {{{WidgetFactoryContext}}}. This class has the following public methods:

|| *Method* || *Description* ||
|| getWidget || Returns the widget previously instantiated be the method {{{instantiateWidget}}} ||
|| getElement || Returns the widget metadata element (the {{{<span>}}} tag) ||
|| getWidgetId || Returns the widget identifier ||
|| setAttribute(String key, Object value) || Allows the factory to set some information to use in some other step of the parser, (like during the children processing) ||
|| getAttribute(String key) || Returns some attribute previously set by method setAttribute||

The next sections describe how  to properly overwrite each of those methods to serve your widget needs.


=== 2.3.1 The instantiateWidget method===


The {{{instantiateWidget}}} method is called to the widget object instantiation. The {{{<span>}}} element is passed as parameter and can be used if the widget to be created needs some attribute in its constructor.If the widget showed on [WidgetDeveloperManual#2.1_Overview section 2.1] needs some attribute, we could write something like:

{{{
@DeclarativeFactory(id="myWidget", library="myLibrary")
public class MyWidgetFactory extends WidgetFactory<MyWidget>
{
   @Override
   public MyWidget instantiateWidget(Element element, String widgetId) 
   {
      return new MyWidget(element.getAttribute("_theRequiredAttribute"));
   }
  ...
}
}}}

The purpose of this method is just instantiate the widget. The best place to handle the extraction of attributes, events and children is not here. You must use the other methods showed bellow.

=== 2.3.2 The processAttributes method===

This method has two goals:
  # Turn easier the binding beetwen the widget metadata element (the {{{<span>}}} tag) and the widget itself.
  # Inform to _*Crux*_ engine which attributes this factory can handle. This information is used to generate a proper XSD file, that can be used to enable autocompletion for developers (See  [UserManual#5.1_Schema_Generator SchemaGenerator]).
  

See the following code:
   
{{{
@DeclarativeFactory(id="myWidget", library="myLibrary")
public class MyWidgetFactory extends WidgetFactory<MyWidget>
{

   @Override
   @TagAttributesDeclaration({
      @TagAttributeDeclaration("myWidgetAttribute")
   })
   public void processAttributes(WidgetFactoryContext<MyWidget> context) throws InterfaceConfigException 
   {
      super.processAttributes(context);
      
      MyWidget widget = context.getWidget();
      String attr = element.getAttribute("_myWidgetAttribute");
      if (StringUtils.isNotEmpty(attr))
      {
         widget.setMyWidgetAttribute(attr);
      }
   }
}
}}}

The first thing done by the above processAttributes method is call {{{super.processAttributes}}}. It is important, once all attributes common to all GWT widgets (like {{{visible, width, height}}} and others) are handled by {{{WidgetFactory.processAttributes}}}. 

Other important point to observe is the annotation {{{@TagAttributesDeclaration}}} on method. It is used to inform all attributes supported by this widget. This information is used by  [UserManual#5.1_Schema_Generator SchemaGenerator]. Note that {{{WidgetFactory.processAttributes}}} has this same annotation including more attributes.   [UserManual#5.1_Schema_Generator SchemaGenerator] will consider attributes declared on super classes to generate the XSD files.


If you observe the code showed on section [WidgetDeveloperManual#2.1_Overview 2.1], you will note that the annotation {{{@TagAttributes}}} is used in the place of {{{@TagAttributesDeclaration}}}. The two annotations are very similar and support the same attributes. However, when you use the {{{@TagAttributes}}}, _*Crux*_ will generate the code for the binding of those attributes. The code on section 2.1 just declare the attribute {{{myWidgetAttribute}}} on the method annotation and does not need to implement all the code showed in this section.

In other words, the above code can bre written as:

{{{
@DeclarativeFactory(id="myWidget", library="myLibrary")
public class MyWidgetFactory extends WidgetFactory<MyWidget>
{
   @Override
   @TagAttributes({
      @TagAttribute("myWidgetAttribute")
   })
   public void processAttributes(WidgetFactoryContext<MyWidget> context) throws InterfaceConfigException 
   {
      super.processAttributes(context);
   }
}
}}}

The annotation {{{@TagAttributesDeclaration}}} must be used when you want to inform _*Crux*_ that the attributes exist (because the [UserManual#5.1_Schema_Generator SchemaGenerator]), but wants to handle the parser programmatically, making some special validations, for example.


You can use both annotations on a processAttributes method. 

{{{
@DeclarativeFactory(id="myWidget", library="myLibrary")
public class MyWidgetFactory extends WidgetFactory<MyWidget>
{
   @Override
   public MyWidget instantiateWidget(Element element, String widgetId) 
   {
      return new MyWidget(element.getAttribute("_theRequiredAttribute"));
   }
   
   @Override
   @TagAttributes({
      @TagAttribute("myWidgetAttribute")
   })
   @TagAttributesDeclaration({
      @TagAttributeDeclaration(value="theRequiredAttribute", required=true)
   })
   public void processAttributes(WidgetFactoryContext<MyWidget> context) throws InterfaceConfigException 
   {
      super.processAttributes(context);
   }
}
}}}

==== 2.3.2.1 @TagAttributes Annotation====

The {{{@TagAttributes}}} has one attribute (value) of type array of {{{@TagAttribute}}}. Each {{{@TagAttribute}}} is used to inform one attribute of the widget.

{{{@TagAttribute}}} accepts the following attributes:

|| *Name* || *Type* || *Required* || *Default* || *Description* ||
|| value || String || yes || - || The name of the attribute. ||
|| defaultValue || String || no || "" || The default value to be used on XSD. ||
|| type || Class<?> || no || String || The type of the attribute. ||
|| required || boolean || no || false || Inform if the attribute is required. ||
|| supportsI18N || boolean || no || false || Inform if the attribute support _*Crux*_ declarative i18n. ||

The supported types for an attribute is:
  * any primitive type or primitive wrapper;
  * String;
  * Date;
  * any enum type.
 
All enum types will be mapped to simpleTypes on the generated XSD. 

The parser generated by _*Crux*_ will handle all type conversions needed and all declarative i18n messages.

All of those properties exists on the annotation {{{@TagAttributesDeclaration}}}. However, with that annotation, the parsing of the {{{<span>}}} element and the binding with the widget is not done automatically.


=== 2.3.3 The processEvents  method===

This method does almost the same as processAttributes, however, it handle widget events.

Two annotations can be used on {{{processEvents}}} method: {{{@TagEvents}}} and {{{@TagEventsDeclaration}}}.

 We can compare these annotations with {{{@TagAttributes}}} and  {{{@TagAttributesDeclaration}}} .

See the following example:

{{{
@DeclarativeFactory(id="myWidget", library="myLibrary")
public class MyWidgetFactory extends WidgetFactory<MyWidget>
{
   @Override
   @TagEvents({
      @TagEvent(ClickEvtBind.class)
   })	
   @TagEventsDeclaration({
      @TagEventDeclaration("onCustomEvent")
   })
   public void processEvents(WidgetFactoryContext<MyWidget> context) throws InterfaceConfigException 
   {
      super.processEvents(context);
      
      final Event eventCustom = EvtBind.getWidgetEvent(context.getElement(), "onCustomEvent");
      if (eventCustom != null)
      {
         context.getWidget().addCustomEventHandler(new CustomEventHandler()
         {
            public void onCustomEvent(CustomEvent event)
            {
               Events.callEvent(eventCustom, event);
            }
         });
      }
   }
}
}}}

==== 2.3.3.1 @TagEvents Annotation====


The {{{@TagEvents}}} has one attribute (value) of type array of {{{@TagEvent}}}. Each {{{@TagEvent}}} is used to inform one event of the widget.

{{{@TagEvent}}} accepts one attribute of type {{{EvtBinder}}}. {{{EvtBinders}}} are classes that can 



The annotation {{{@TagEventsDeclaration}}} has one 

=== 2.3.4 The processChildren  method===


=== 2.3.5 The postProcess  method===


