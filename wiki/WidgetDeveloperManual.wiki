= 1 Introduction =

If you are not familiar with _*Crux*_ framework using, please consult the [UserManual User Manual] first.

This documentation will show you how to work with custom widgets inside _*Crux*_. 

== 1.1 GWT widgets ==

_*Crux*_ widgets are  [http://code.google.com/intl/pt-BR/webtoolkit/doc/latest/DevGuideUiWidgets.html GWT widgets]. _*Crux*_ just offer an aditional engine where those widgets can be plugged.

So, you can plug any custom widgets in _*Crux*_ Declarative Engine. If you are not familiar with GWT widgets development, please consult its documentation  [http://code.google.com/intl/pt-BR/webtoolkit/doc/latest/DevGuideUiWidgets.html first].

= 2 _Crux_ Declarative Engine = 

== 2.1 Overview == 

_*Crux*_ declarative engine uses factories to create the widgets based on informations contained inside the html pages. For a deeper explanation about how this declarative engine works, consult the following  [DeclarativeEngine tutorial].

To register a custom widget in _*Crux*_ declarative engine, you just have to create a factory class for it.

See the following example:

{{{
@DeclarativeFactory(id="myWidget", library="myLibrary")
public class MyWidgetFactory extends WidgetFactory<MyWidget>
{
   @Override
   public MyWidget instantiateWidget(Element element, String widgetId) 
   {
      return new MyWidget();
   }
	
   @Override
   @TagAttributes({
      @TagAttribute("myWidgetAttribute"),
   })
   public void processAttributes(WidgetFactoryContext<MyWidget> context) throws InterfaceConfigException {}
}
}}}

Note that the above class uses the annotation {{{@DeclarativeFactory}}} and extends the abstract class {{{WidgetFactory}}}. These two conditions are necessary for any _*Crux*_ widget factory.

Through the {{{@DeclarativeFactory}}} annotation, you can specify the name of the library where your widget will be registered and the name that will be associated with your widget itself. 

Before we go deeper inside the code showed and see more examples, let's see how you could use the widget registered with _*Crux*_ declarative engine:

{{{
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:mylib="http://www.sysmap.com.br/crux/myLibrary" >
   <head>
       <script language="javascript" src="cruxtest/cruxtest.nocache.js"></script>
   </head>
   <body>
       <mylib:myWidget id="myBox" myWidgetAttribute="attributeValue"/>
   </body>
</html>
}}} 


Note that a namespace called {{{http://www.sysmap.com.br/crux/myLibrary}}} is used on the above page. A {{{XSD}}} file defining this namespace is created by the [UserManual#5.1_Schema_Generator SchemaGenerator].

The example showed assumes that the widget {{{MyWidget}}} contains a public String property called {{{myWidgetAttribute}}} that will be bounded to the tag attribute {{{myWidgetAttribute}}}.


== 2.2 WidgetFactory ==